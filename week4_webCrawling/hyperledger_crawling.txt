https://hyperledger-fabric.readthedocs.io/en/release-2.0/whatis.html



Docs »
Introduction

 Edit on GitHub







IntroductionÂ¶
In general terms, a blockchain is an immutable transaction ledger, maintained
within a distributed network of peer nodes. These nodes each maintain a copy
of the ledger by applying transactions that have been validated by a consensus
protocol, grouped into blocks that include a hash that bind each block to the
preceding block.
The first and most widely recognized application of blockchain is the
Bitcoin cryptocurrency, though others
have followed in its footsteps. Ethereum, an alternative cryptocurrency, took a
different approach, integrating many of the same characteristics as Bitcoin but
adding smart contracts to create a platform for distributed applications.
Bitcoin and Ethereum fall into a class of blockchain that we would classify as
public permissionless blockchain technology. Basically, these are public
networks, open to anyone, where participants interact anonymously.
As the popularity of Bitcoin, Ethereum and a few other derivative technologies
grew, interest in applying the underlying technology of the blockchain,
distributed ledger and distributed application platform to more innovative
enterprise use cases also grew. However, many enterprise use cases require
performance characteristics that the permissionless blockchain technologies are
unable (presently) to deliver. In addition, in many use cases, the identity of
the participants is a hard requirement, such as in the case of financial
transactions where Know-Your-Customer (KYC) and Anti-Money Laundering (AML)
regulations must be followed.
For enterprise use, we need to consider the following requirements:

Participants must be identified/identifiable
Networks need to be permissioned
High transaction throughput performance
Low latency of transaction confirmation
Privacy and confidentiality of transactions and data pertaining to business
transactions

While many early blockchain platforms are currently being adapted for
enterprise use, Hyperledger Fabric has been designed for enterprise use from
the outset. The following sections describe how Hyperledger Fabric (Fabric)
differentiates itself from other blockchain platforms and describes some of the
motivation for its architectural decisions.

Hyperledger FabricÂ¶
Hyperledger Fabric is an open source enterprise-grade permissioned distributed
ledger technology (DLT) platform, designed for use in enterprise contexts,
that delivers some key differentiating capabilities over other popular
distributed ledger or blockchain platforms.
One key point of differentiation is that Hyperledger was established under the
Linux Foundation, which itself has a long and very successful history of
nurturing open source projects under open governance that grow strong
sustaining communities and thriving ecosystems. Hyperledger is governed by a
diverse technical steering committee, and the Hyperledger Fabric project by a
diverse set of maintainers from multiple organizations. It has a development
community that has grown to over 35 organizations and nearly 200 developers
since its earliest commits.
Fabric has a highly modular and configurable architecture, enabling
innovation, versatility and optimization for a broad range of industry use cases
including banking, finance, insurance, healthcare, human resources, supply
chain and even digital music delivery.
Fabric is the first distributed ledger platform to support smart contracts
authored in general-purpose programming languages such as Java, Go and
Node.js, rather than constrained domain-specific languages (DSL). This means
that most enterprises already have the skill set needed to develop smart
contracts, and no additional training to learn a new language or DSL is needed.
The Fabric platform is also permissioned, meaning that, unlike with a public
permissionless network, the participants are known to each other, rather than
anonymous and therefore fully untrusted. This means that while the participants
may not fully trust one another (they may, for example, be competitors in the
same industry), a network can be operated under a governance model that is built
off of what trust does exist between participants, such as a legal agreement
or framework for handling disputes.
One of the most important of the platformâs differentiators is its support for
pluggable consensus protocols that enable the platform to be more
effectively customized to fit particular use cases and trust models. For
instance, when deployed within a single enterprise, or operated by a trusted
authority, fully byzantine fault tolerant consensus might be considered
unnecessary and an excessive drag on performance and throughput. In situations
such as that, a
crash fault-tolerant (CFT)
consensus protocol might be more than adequate whereas, in a multi-party,
decentralized use case, a more traditional
byzantine fault tolerant
(BFT) consensus protocol might be required.
Fabric can leverage consensus protocols that do not require a native
cryptocurrency to incent costly mining or to fuel smart contract execution.
Avoidance of a cryptocurrency reduces some significant risk/attack vectors,
and absence of cryptographic mining operations means that the platform can be
deployed with roughly the same operational cost as any other distributed system.
The combination of these differentiating design features makes Fabric one of
the better performing platforms available today both in terms of transaction
processing and transaction confirmation latency, and it enables privacy and confidentiality of transactions and the smart contracts (what Fabric calls
âchaincodeâ) that implement them.
Letâs explore these differentiating features in more detail.


ModularityÂ¶
Hyperledger Fabric has been specifically architected to have a modular
architecture. Whether it is pluggable consensus, pluggable identity management
protocols such as LDAP or OpenID Connect, key management protocols or
cryptographic libraries, the platform has been designed at its core to be
configured to meet the diversity of enterprise use case requirements.
At a high level, Fabric is comprised of the following modular components:

A pluggable ordering service establishes consensus on the order of
transactions and then broadcasts blocks to peers.
A pluggable membership service provider is responsible for associating
entities in the network with cryptographic identities.
An optional peer-to-peer gossip service disseminates the blocks output by
ordering service to other peers.
Smart contracts (âchaincodeâ) run within a container environment (e.g. Docker)
for isolation. They can be written in standard programming languages but do not
have direct access to the ledger state.
The ledger can be configured to support a variety of DBMSs.
A pluggable endorsement and validation policy enforcement that can be
independently configured per application.

There is fair agreement in the industry that there is no âone blockchain to
rule them allâ. Hyperledger Fabric can be configured in multiple ways to
satisfy the diverse solution requirements for multiple industry use cases.


Permissioned vs Permissionless BlockchainsÂ¶
In a permissionless blockchain, virtually anyone can participate, and every
participant is anonymous. In such a context, there can be no trust other than
that the state of the blockchain, prior to a certain depth, is immutable. In
order to mitigate this absence of trust, permissionless blockchains typically
employ a âminedâ native cryptocurrency or transaction fees to provide economic
incentive to offset the extraordinary costs of participating in a form of
byzantine fault tolerant consensus based on âproof of workâ (PoW).
Permissioned blockchains, on the other hand, operate a blockchain amongst
a set of known, identified and often vetted participants operating under a
governance model that yields a certain degree of trust. A permissioned
blockchain provides a way to secure the interactions among a group of entities
that have a common goal but which may not fully trust each other. By relying on
the identities of the participants, a permissioned blockchain can use more
traditional crash fault tolerant (CFT) or byzantine fault tolerant (BFT)
consensus protocols that do not require costly mining.
Additionally, in such a permissioned context, the risk of a participant
intentionally introducing malicious code through a smart contract is diminished.
First, the participants are known to one another and all actions, whether
submitting application transactions, modifying the configuration of the network
or deploying a smart contract are recorded on the blockchain following an
endorsement policy that was established for the network and relevant transaction
type. Rather than being completely anonymous, the guilty party can be easily
identified and the incident handled in accordance with the terms of the
governance model.


Smart ContractsÂ¶
A smart contract, or what Fabric calls âchaincodeâ, functions as a trusted
distributed application that gains its security/trust from the blockchain and
the underlying consensus among the peers. It is the business logic of a
blockchain application.
There are three key points that apply to smart contracts, especially when
applied to a platform:

many smart contracts run concurrently in the network,
they may be deployed dynamically (in many cases by anyone), and
application code should be treated as untrusted, potentially even
malicious.

Most existing smart-contract capable blockchain platforms follow an
order-execute architecture in which the consensus protocol:

validates and orders transactions then propagates them to all peer nodes,
each peer then executes the transactions sequentially.

The order-execute architecture can be found in virtually all existing blockchain
systems, ranging from public/permissionless platforms such as
Ethereum (with PoW-based consensus) to permissioned
platforms such as Tendermint,
Chain, and Quorum.
Smart contracts executing in a blockchain that operates with the order-execute
architecture must be deterministic; otherwise, consensus might never be reached.
To address the non-determinism issue, many platforms require that the smart
contracts be written in a non-standard, or domain-specific language
(such as Solidity) so that
non-deterministic operations can be eliminated. This hinders wide-spread
adoption because it requires developers writing smart contracts to learn a new
language and may lead to programming errors.
Further, since all transactions are executed sequentially by all nodes,
performance and scale is limited. The fact that the smart contract code executes
on every node in the system demands that complex measures be taken to protect
the overall system from potentially malicious contracts in order to ensure
resiliency of the overall system.


A New ApproachÂ¶
Fabric introduces a new architecture for transactions that we call
execute-order-validate. It addresses the resiliency, flexibility,
scalability, performance and confidentiality challenges faced by the
order-execute model by separating the transaction flow into three steps:

execute a transaction and check its correctness, thereby endorsing it,
order transactions via a (pluggable) consensus protocol, and
validate transactions against an application-specific endorsement policy
before committing them to the ledger

This design departs radically from the order-execute paradigm in that Fabric
executes transactions before reaching final agreement on their order.
In Fabric, an application-specific endorsement policy specifies which peer
nodes, or how many of them, need to vouch for the correct execution of a given
smart contract. Thus, each transaction need only be executed (endorsed) by the
subset of the peer nodes necessary to satisfy the transactionâs endorsement
policy. This allows for parallel execution increasing overall performance and
scale of the system. This first phase also eliminates any non-determinism,
as inconsistent results can be filtered out before ordering.
Because we have eliminated non-determinism, Fabric is the first blockchain
technology that enables use of standard programming languages.


Privacy and ConfidentialityÂ¶
As we have discussed, in a public, permissionless blockchain network that
leverages PoW for its consensus model, transactions are executed on every node.
This means that neither can there be confidentiality of the contracts
themselves, nor of the transaction data that they process. Every transaction,
and the code that implements it, is visible to every node in the network. In
this case, we have traded confidentiality of contract and data for byzantine
fault tolerant consensus delivered by PoW.
This lack of confidentiality can be problematic for many business/enterprise use
cases. For example, in a network of supply-chain partners, some consumers might
be given preferred rates as a means of either solidifying a relationship, or
promoting additional sales. If every participant can see every contract and
transaction, it becomes impossible to maintain such business relationships in a
completely transparent network â everyone will want the preferred rates!
As a second example, consider the securities industry, where a trader building
a position (or disposing of one) would not want her competitors to know of this,
or else they will seek to get in on the game, weakening the traderâs gambit.
In order to address the lack of privacy and confidentiality for purposes of
delivering on enterprise use case requirements, blockchain platforms have
adopted a variety of approaches. All have their trade-offs.
Encrypting data is one approach to providing confidentiality; however, in a
permissionless network leveraging PoW for its consensus, the encrypted data is
sitting on every node. Given enough time and computational resource, the
encryption could be broken. For many enterprise use cases, the risk that their
information could become compromised is unacceptable.
Zero knowledge proofs (ZKP) are another area of research being explored to
address this problem, the trade-off here being that, presently, computing a ZKP
requires considerable time and computational resources. Hence, the trade-off in
this case is performance for confidentiality.
In a permissioned context that can leverage alternate forms of consensus, one
might explore approaches that restrict the distribution of confidential
information exclusively to authorized nodes.
Hyperledger Fabric, being a permissioned platform, enables confidentiality
through its channel architecture and private data
feature. In channels, participants on a Fabric network establish a sub-network
where every member has visibility to a particular set of transactions. Thus, only
those nodes that participate in a channel have access to the smart contract
(chaincode) and data transacted, preserving the privacy and confidentiality of
both. Private data allows collections between members on a channel, allowing
much of the same protection as channels without the maintenance overhead of
creating and maintaining a separate channel.


Pluggable ConsensusÂ¶
The ordering of transactions is delegated to a modular component for consensus
that is logically decoupled from the peers that execute transactions and
maintain the ledger. Specifically, the ordering service. Since consensus is
modular, its implementation can be tailored to the trust assumption of a
particular deployment or solution. This modular architecture allows the platform
to rely on well-established toolkits for CFT (crash fault-tolerant) or BFT
(byzantine fault-tolerant) ordering.
Fabric currently offers a CFT ordering service implementation
based on the etcd library of the Raft protocol.
For information about currently available ordering services, check
out our conceptual documentation about ordering.
Note also that these are not mutually exclusive. A Fabric network can have
multiple ordering services supporting different applications or application
requirements.


Performance and ScalabilityÂ¶
Performance of a blockchain platform can be affected by many variables such as
transaction size, block size, network size, as well as limits of the hardware,
etc. The Hyperledger Fabric Performance and Scale working group
currently works on a benchmarking framework called Hyperledger Caliper.
Several research papers have been published studying and testing the performance
capabilities of Hyperledger Fabric. The latest scaled Fabric to 20,000 transactions per second.


ConclusionÂ¶
Any serious evaluation of blockchain platforms should include Hyperledger Fabric
in its short list.
Combined, the differentiating capabilities of Fabric make it a highly scalable
system for permissioned blockchains supporting flexible trust assumptions that
enable the platform to support a wide range of industry use cases ranging from
government, to finance, to supply-chain logistics, to healthcare and so much
more.
Hyperledger Fabric is the most active of the Hyperledger projects. The community
building around the platform is growing steadily, and the innovation delivered
with each successive release far out-paces any of the other enterprise blockchain
platforms.


AcknowledgementÂ¶
The preceding is derived from the peer reviewed
âHyperledger Fabric: A Distributed Operating System for Permissioned Blockchainsâ - Elli Androulaki, Artem
Barger, Vita Bortnikov, Christian Cachin, Konstantinos Christidis, Angelo De
Caro, David Enyeart, Christopher Ferris, Gennady Laventman, Yacov Manevich,
Srinivasan Muralidharan, Chet Murthy, Binh Nguyen, Manish Sethi, Gari Singh,
Keith Smith, Alessandro Sorniotti, Chrysoula Stathakopoulou, Marko Vukolic,
Sharon Weed Cocco, Jason Yellick








Next 
 Previous




        © Copyright Hyperledger 2020.
    
This work is licensed under a Creative Commons Attribution 4.0 International License



          Revision 77bafd68.
        


  Built with Sphinx using a theme provided by Read the Docs. 



https://hyperledger-fabric.readthedocs.io/en/release-2.0/whatsnew.html



Docs »
Whatâs new in Hyperledger Fabric v2.0

 Edit on GitHub







Whatâs new in Hyperledger Fabric v2.0Â¶
The first Hyperledger Fabric major release since v1.0, Fabric v2.0
delivers important new features and changes for users and operators alike,
including support for new application and privacy patterns, enhanced
governance around smart contracts, and new options for operating nodes.
What has stayed the same is the ability to upgrade network components on
your own terms, with support for rolling upgrades from v1.4.x, and the ability
to enable the new capabilities only when member organizations are ready.
Letâs take a look at some of the highlights of the Fabric v2.0 releaseâ¦

Decentralized governance for smart contractsÂ¶
Fabric v2.0 introduces decentralized governance for smart contracts, with a new
process for installing a chaincode on your peers and starting it on a channel.
The new Fabric chaincode lifecycle allows multiple organizations to come to
agreement on the parameters of a chaincode, such as the chaincode endorsement
policy, before it can be used to interact with the ledger. The new model
offers several improvements over the previous lifecycle:

Multiple organizations must agree to the parameters of a chaincode
In the release 1.x versions of Fabric, one organization had the ability to
set parameters of a chaincode (for instance the endorsement policy) for all
other channel members, who only had the power to refuse to install the chaincode
and therefore not take part in transactions invoking it. The new Fabric
chaincode lifecycle is more flexible since it supports both centralized
trust models (such as that of the previous lifecycle model) as well as
decentralized models requiring a sufficient number of organizations to
agree on an endorsement policy and other details before the chaincode
becomes active on a channel.
More deliberate chaincode upgrade process In the previous chaincode
lifecycle, the upgrade transaction could be issued by a single organization,
creating a risk for a channel member that had not yet installed the new
chaincode. The new model allows for a chaincode to be upgraded only after
a sufficient number of organizations have approved the upgrade.
Simpler endorsement policy and private data collection updates
Fabric lifecycle allows you to change an endorsement policy or private
data collection configuration without having to repackage or reinstall
the chaincode. Users can also take advantage of a new default endorsement
policy that requires endorsement from a majority of organizations on the
channel. This policy is updated automatically when organizations are
added or removed from the channel.
Inspectable chaincode packages The Fabric lifecycle packages chaincode
in easily readable tar files. This makes it easier to inspect the chaincode
package and coordinate installation across multiple organizations.
Start multiple chaincodes on a channel using one package The previous
lifecycle defined each chaincode on the channel using a name and version
that was specified when the chaincode package was installed. You can now
use a single chaincode package and deploy it multiple times with different
names on the same channel or on different channels. For example, if youâd
like to track different types of assets in their own âcopyâ of the chaincode.
Chaincode packages do not need to be identical across channel members
Organizations can extend a chaincode for their own use case, for example
to perform different validations in the interest of their organization.
As long as the required number of organizations endorse chaincode transactions
with matching results, the transaction will be validated and committed to the
ledger.  This also allows organizations to individually roll out minor fixes
on their own schedules without requiring the entire network to proceed in lock-step.


Using the new chaincode lifecycleÂ¶
For existing Fabric deployments, you can continue to use the prior chaincode
lifecycle with Fabric v2.0. The new chaincode lifecycle will become effective
only when the channel application capability is updated to v2.0.
See the Fabric chaincode lifecycle concept topic for an overview of the new
chaincode lifecycle.



New chaincode application patterns for collaboration and consensusÂ¶
The same decentralized methods of coming to agreement that underpin the
new chaincode lifecycle management can also be used in your own chaincode
applications to ensure organizations consent to data transactions before
they are committed to the ledger.

Automated checks As mentioned above, organizations can add automated
checks to chaincode functions to validate additional information before
endorsing a transaction proposal.
Decentralized agreement Human decisions can be modeled into a chaincode process
that spans multiple transactions. The chaincode may require actors from
various organizations to indicate their terms and conditions of agreement
in a ledger transaction. Then, a final chaincode proposal can
verify that the conditions from all the individual transactors are met,
and âsettleâ the business transaction with finality across all channel
members. For a concrete example of indicating terms and conditions in private,
see the asset transfer scenario in the Private data documentation.



Private data enhancementsÂ¶
Fabric v2.0 also enables new patterns for working with and sharing private data,
without the requirement of creating private data collections for all
combinations of channel members that may want to transact. Specifically,
instead of sharing private data within a collection of multiple members,
you may want to share private data across collections, where each collection
may include a single organization, or perhaps a single organization along
with a regulator or auditor.
Several enhancements in Fabric v2.0 make these new private data patterns possible:

Sharing and verifying private data When private data is shared with a
channel member who is not a member of a collection, or shared with another
private data collection that contains one or more channel members (by writing
a key to that collection), the receiving parties can utilize the
GetPrivateDataHash() chaincode API to verify that the private data matches the
on-chain hashes that were created from private data in previous transactions.
Collection-level endorsement policies Private data collections can now
optionally be defined with an endorsement policy that overrides the
chaincode-level endorsement policy for keys within the collection. This
feature can be used to restrict which organizations can write data to a
collection, and is what enables the new chaincode lifecycle and chaincode
application patterns mentioned earlier. For example, you may have a chaincode
endorsement policy that requires a majority of organizations to endorse,
but for any given transaction, you may need two transacting organizations
to individually endorse their agreement in their own private data collections.
Implicit per-organization collections If youâd like to utilize
per-organization private data patterns, you donât even need to define the
collections when deploying chaincode in Fabric v2.0.  Implicit
organization-specific collections can be used without any upfront definition.

To learn more about the new private data patterns, see the Private data (conceptual
documentation). For details about private data collection configuration and
implicit collections, see the Private Data (reference documentation).


External chaincode launcherÂ¶
The external chaincode launcher feature empowers operators to build and launch
chaincode with the technology of their choice. Use of external builders and launchers
is not required as the default behavior builds and runs chaincode in the same manner
as prior releases using the Docker API.

Eliminate Docker daemon dependency Prior releases of Fabric required
peers to have access to a Docker daemon in order to build and launch
chaincode - something that may not be desirable in production environments
due to the privileges required by the peer process.
Alternatives to containers Chaincode is no longer required to be run
in Docker containers, and may be executed in the operatorâs choice of
environment (including containers).
External builder executables An operator can provide a set of external
builder executables to override how the peer builds and launches chaincode.
Chaincode as an external service Traditionally, chaincodes are launched
by the peer, and then connect back to the peer. It is now possible to run chaincode as
an external service, for example in a Kubernetes pod, which a peer can
connect to and utilize for chaincode execution. See Chaincode as an external service for more
information.

See External Builders and Launchers to learn more about the external chaincode launcher feature.


State database cache for improved performance on CouchDBÂ¶

When using external CouchDB state database, read delays during endorsement
and validation phases have historically been a performance bottleneck.
With Fabric v2.0, a new peer cache replaces many of these expensive lookups
with fast local cache reads. The cache size can be configured by using the
core.yaml property cacheSize.



Alpine-based docker imagesÂ¶
Starting with v2.0, Hyperledger Fabric Docker images will use Alpine Linux,
a security-oriented, lightweight Linux distribution. This means that Docker
images are now much smaller, providing faster download and startup times,
as well as taking up less disk space on host systems. Alpine Linux is designed
from the ground up with security in mind, and the minimalist nature of the Alpine
distribution greatly reduces the risk of security vulnerabilities.


Sample test networkÂ¶
The fabric-samples repository now includes a new Fabric test network. The test
network is built to be a modular and user friendly sample Fabric network that
makes it easy to test your applications and smart contracts. The network also
supports the ability to deploy your network using Certificate Authorities,
in addition to cryptogen.
For more information about this network, check out Using the Fabric test network.


Upgrading to Fabric v2.0Â¶
A major new release brings some additional upgrade considerations. Rest assured
though, that rolling upgrades from v1.4.x to v2.0 are supported, so that network
components can be upgraded one at a time with no downtime.
The upgrade docs have been significantly expanded and reworked, and now have a
standalone home in the documentation: Upgrading to the latest release. Here youâll find documentation on
Upgrading your components and Updating the capability level of a channel, as well as a
specific look  at the considerations for upgrading to v2.0, Considerations for getting to v2.0.



Release notesÂ¶
The release notes provide more details for users moving to the new release.
Specifically, take a look at the changes and deprecations that are being
announced with the new Fabric v2.0 release.

Fabric v2.0.0 release notes.
Fabric v2.0.1 release notes.








Next 
 Previous




        © Copyright Hyperledger 2020.
    
This work is licensed under a Creative Commons Attribution 4.0 International License



          Revision 77bafd68.
        


  Built with Sphinx using a theme provided by Read the Docs. 



https://hyperledger-fabric.readthedocs.io/en/release-2.0/whatsnew.html#release-notes



Docs »
Whatâs new in Hyperledger Fabric v2.0

 Edit on GitHub







Whatâs new in Hyperledger Fabric v2.0Â¶
The first Hyperledger Fabric major release since v1.0, Fabric v2.0
delivers important new features and changes for users and operators alike,
including support for new application and privacy patterns, enhanced
governance around smart contracts, and new options for operating nodes.
What has stayed the same is the ability to upgrade network components on
your own terms, with support for rolling upgrades from v1.4.x, and the ability
to enable the new capabilities only when member organizations are ready.
Letâs take a look at some of the highlights of the Fabric v2.0 releaseâ¦

Decentralized governance for smart contractsÂ¶
Fabric v2.0 introduces decentralized governance for smart contracts, with a new
process for installing a chaincode on your peers and starting it on a channel.
The new Fabric chaincode lifecycle allows multiple organizations to come to
agreement on the parameters of a chaincode, such as the chaincode endorsement
policy, before it can be used to interact with the ledger. The new model
offers several improvements over the previous lifecycle:

Multiple organizations must agree to the parameters of a chaincode
In the release 1.x versions of Fabric, one organization had the ability to
set parameters of a chaincode (for instance the endorsement policy) for all
other channel members, who only had the power to refuse to install the chaincode
and therefore not take part in transactions invoking it. The new Fabric
chaincode lifecycle is more flexible since it supports both centralized
trust models (such as that of the previous lifecycle model) as well as
decentralized models requiring a sufficient number of organizations to
agree on an endorsement policy and other details before the chaincode
becomes active on a channel.
More deliberate chaincode upgrade process In the previous chaincode
lifecycle, the upgrade transaction could be issued by a single organization,
creating a risk for a channel member that had not yet installed the new
chaincode. The new model allows for a chaincode to be upgraded only after
a sufficient number of organizations have approved the upgrade.
Simpler endorsement policy and private data collection updates
Fabric lifecycle allows you to change an endorsement policy or private
data collection configuration without having to repackage or reinstall
the chaincode. Users can also take advantage of a new default endorsement
policy that requires endorsement from a majority of organizations on the
channel. This policy is updated automatically when organizations are
added or removed from the channel.
Inspectable chaincode packages The Fabric lifecycle packages chaincode
in easily readable tar files. This makes it easier to inspect the chaincode
package and coordinate installation across multiple organizations.
Start multiple chaincodes on a channel using one package The previous
lifecycle defined each chaincode on the channel using a name and version
that was specified when the chaincode package was installed. You can now
use a single chaincode package and deploy it multiple times with different
names on the same channel or on different channels. For example, if youâd
like to track different types of assets in their own âcopyâ of the chaincode.
Chaincode packages do not need to be identical across channel members
Organizations can extend a chaincode for their own use case, for example
to perform different validations in the interest of their organization.
As long as the required number of organizations endorse chaincode transactions
with matching results, the transaction will be validated and committed to the
ledger.  This also allows organizations to individually roll out minor fixes
on their own schedules without requiring the entire network to proceed in lock-step.


Using the new chaincode lifecycleÂ¶
For existing Fabric deployments, you can continue to use the prior chaincode
lifecycle with Fabric v2.0. The new chaincode lifecycle will become effective
only when the channel application capability is updated to v2.0.
See the Fabric chaincode lifecycle concept topic for an overview of the new
chaincode lifecycle.



New chaincode application patterns for collaboration and consensusÂ¶
The same decentralized methods of coming to agreement that underpin the
new chaincode lifecycle management can also be used in your own chaincode
applications to ensure organizations consent to data transactions before
they are committed to the ledger.

Automated checks As mentioned above, organizations can add automated
checks to chaincode functions to validate additional information before
endorsing a transaction proposal.
Decentralized agreement Human decisions can be modeled into a chaincode process
that spans multiple transactions. The chaincode may require actors from
various organizations to indicate their terms and conditions of agreement
in a ledger transaction. Then, a final chaincode proposal can
verify that the conditions from all the individual transactors are met,
and âsettleâ the business transaction with finality across all channel
members. For a concrete example of indicating terms and conditions in private,
see the asset transfer scenario in the Private data documentation.



Private data enhancementsÂ¶
Fabric v2.0 also enables new patterns for working with and sharing private data,
without the requirement of creating private data collections for all
combinations of channel members that may want to transact. Specifically,
instead of sharing private data within a collection of multiple members,
you may want to share private data across collections, where each collection
may include a single organization, or perhaps a single organization along
with a regulator or auditor.
Several enhancements in Fabric v2.0 make these new private data patterns possible:

Sharing and verifying private data When private data is shared with a
channel member who is not a member of a collection, or shared with another
private data collection that contains one or more channel members (by writing
a key to that collection), the receiving parties can utilize the
GetPrivateDataHash() chaincode API to verify that the private data matches the
on-chain hashes that were created from private data in previous transactions.
Collection-level endorsement policies Private data collections can now
optionally be defined with an endorsement policy that overrides the
chaincode-level endorsement policy for keys within the collection. This
feature can be used to restrict which organizations can write data to a
collection, and is what enables the new chaincode lifecycle and chaincode
application patterns mentioned earlier. For example, you may have a chaincode
endorsement policy that requires a majority of organizations to endorse,
but for any given transaction, you may need two transacting organizations
to individually endorse their agreement in their own private data collections.
Implicit per-organization collections If youâd like to utilize
per-organization private data patterns, you donât even need to define the
collections when deploying chaincode in Fabric v2.0.  Implicit
organization-specific collections can be used without any upfront definition.

To learn more about the new private data patterns, see the Private data (conceptual
documentation). For details about private data collection configuration and
implicit collections, see the Private Data (reference documentation).


External chaincode launcherÂ¶
The external chaincode launcher feature empowers operators to build and launch
chaincode with the technology of their choice. Use of external builders and launchers
is not required as the default behavior builds and runs chaincode in the same manner
as prior releases using the Docker API.

Eliminate Docker daemon dependency Prior releases of Fabric required
peers to have access to a Docker daemon in order to build and launch
chaincode - something that may not be desirable in production environments
due to the privileges required by the peer process.
Alternatives to containers Chaincode is no longer required to be run
in Docker containers, and may be executed in the operatorâs choice of
environment (including containers).
External builder executables An operator can provide a set of external
builder executables to override how the peer builds and launches chaincode.
Chaincode as an external service Traditionally, chaincodes are launched
by the peer, and then connect back to the peer. It is now possible to run chaincode as
an external service, for example in a Kubernetes pod, which a peer can
connect to and utilize for chaincode execution. See Chaincode as an external service for more
information.

See External Builders and Launchers to learn more about the external chaincode launcher feature.


State database cache for improved performance on CouchDBÂ¶

When using external CouchDB state database, read delays during endorsement
and validation phases have historically been a performance bottleneck.
With Fabric v2.0, a new peer cache replaces many of these expensive lookups
with fast local cache reads. The cache size can be configured by using the
core.yaml property cacheSize.



Alpine-based docker imagesÂ¶
Starting with v2.0, Hyperledger Fabric Docker images will use Alpine Linux,
a security-oriented, lightweight Linux distribution. This means that Docker
images are now much smaller, providing faster download and startup times,
as well as taking up less disk space on host systems. Alpine Linux is designed
from the ground up with security in mind, and the minimalist nature of the Alpine
distribution greatly reduces the risk of security vulnerabilities.


Sample test networkÂ¶
The fabric-samples repository now includes a new Fabric test network. The test
network is built to be a modular and user friendly sample Fabric network that
makes it easy to test your applications and smart contracts. The network also
supports the ability to deploy your network using Certificate Authorities,
in addition to cryptogen.
For more information about this network, check out Using the Fabric test network.


Upgrading to Fabric v2.0Â¶
A major new release brings some additional upgrade considerations. Rest assured
though, that rolling upgrades from v1.4.x to v2.0 are supported, so that network
components can be upgraded one at a time with no downtime.
The upgrade docs have been significantly expanded and reworked, and now have a
standalone home in the documentation: Upgrading to the latest release. Here youâll find documentation on
Upgrading your components and Updating the capability level of a channel, as well as a
specific look  at the considerations for upgrading to v2.0, Considerations for getting to v2.0.



Release notesÂ¶
The release notes provide more details for users moving to the new release.
Specifically, take a look at the changes and deprecations that are being
announced with the new Fabric v2.0 release.

Fabric v2.0.0 release notes.
Fabric v2.0.1 release notes.








Next 
 Previous




        © Copyright Hyperledger 2020.
    
This work is licensed under a Creative Commons Attribution 4.0 International License



          Revision 77bafd68.
        


  Built with Sphinx using a theme provided by Read the Docs. 



https://hyperledger-fabric.readthedocs.io/en/release-2.0/key_concepts.html



Docs »
Key Concepts

 Edit on GitHub







Key ConceptsÂ¶


Introduction
Hyperledger Fabric Model
Blockchain network
Identity
Membership Service Provider (MSP)
Policies
Peers
Ledger
The Ordering Service
Smart Contracts and Chaincode
Fabric chaincode lifecycle
Private data
Channel capabilities
Use Cases









Next 
 Previous




        © Copyright Hyperledger 2020.
    
This work is licensed under a Creative Commons Attribution 4.0 International License



          Revision 77bafd68.
        


  Built with Sphinx using a theme provided by Read the Docs. 



https://hyperledger-fabric.readthedocs.io/en/release-2.0/getting_started.html



Docs »
Getting Started

 Edit on GitHub







Getting StartedÂ¶


Before we begin, if you havenât already done so, you may wish to check that
you have all the Prerequisites installed on the platform(s)
on which youâll be developing blockchain applications and/or operating
Hyperledger Fabric.
Once you have the prerequisites installed, you are ready to download and
install HyperLedger Fabric. While we work on developing real installers for the
Fabric binaries, we provide a script that will Install Samples, Binaries and Docker Images to your system.
The script also will download the Docker images to your local registry.
After you have downloaded the Fabric Samples and Docker images to your local
machine, you can get started working with Fabric with the
Using the Fabric test network tutorial.

Hyperledger Fabric smart contract (chaincode) APIsÂ¶
Hyperledger Fabric offers a number of APIs to support developing smart contracts (chaincode)
in various programming languages. Smart contract APIs are available for Go, Node.js, and Java:


Go contract-api.
Node.js contract API and Node.js contract API documentation.
Java contract API and Java contract API documentation.




Hyperledger Fabric application SDKsÂ¶
Hyperledger Fabric offers a number of SDKs to support developing applications
in various programming languages. SDKs are available for Node.js and Java:


Node.js SDK and Node.js SDK documentation.
Java SDK and Java SDK documentation.


In addition, there are two more application SDKs that have not yet been officially released
(for Python and Go), but they are still available for downloading and testing:


Python SDK.
Go SDK.


Currently, Node.js and Java support the new application programming model delivered in
Hyperledger Fabric v1.4. Support for Go is planned to be delivered in a later release.


Hyperledger Fabric CAÂ¶
Hyperledger Fabric provides an optional
certificate authority service
that you may choose to use to generate the certificates and key material
to configure and manage identity in your blockchain network. However, any CA
that can generate ECDSA certificates may be used.








Next 
 Previous




        © Copyright Hyperledger 2020.
    
This work is licensed under a Creative Commons Attribution 4.0 International License



          Revision 77bafd68.
        


  Built with Sphinx using a theme provided by Read the Docs. 



https://hyperledger-fabric.readthedocs.io/en/release-2.0/developapps/developing_applications.html



Docs »
Developing Applications

 Edit on GitHub







Developing ApplicationsÂ¶


This topic covers how to develop a client application and smart contract to
solve a business problem using Hyperledger Fabric. In a real world Commercial
Paper scenario, involving multiple organizations, youâll learn about all the
concepts and tasks required to accomplish this goal. We assume that the
blockchain network is already available.
The topic is designed for multiple audiences:

Solution and application architect
Client application developer
Smart contract developer
Business professional

You can choose to read the topic in order, or you can select individual sections
as appropriate. Individual topic sections are marked according to reader
relevance, so whether youâre looking for business or technical information itâll
be clear when a topic is for you.
The topic follows a typical software development lifecycle. It starts with
business requirements, and then covers all the major technical activities
required to develop an application and smart contract to meet these
requirements.
If youâd prefer, you can try out the commercial paper scenario immediately,
following an abbreviated explanation, by running the commercial paper tutorial. You can return to this topic when you
need fuller explanations of the concepts introduced in the tutorial.







Next 
 Previous




        © Copyright Hyperledger 2020.
    
This work is licensed under a Creative Commons Attribution 4.0 International License



          Revision 77bafd68.
        


  Built with Sphinx using a theme provided by Read the Docs. 



https://hyperledger-fabric.readthedocs.io/en/release-2.0/tutorials.html



Docs »
Tutorials

 Edit on GitHub







TutorialsÂ¶
Application developers can use the Fabric tutorials to get started building their
own solutions. Start working with Fabric by deploying the test network
on your local machine. You can then use the steps provided by the Deploying a smart contract to a channel
tutorial to deploy and test your smart contracts. The Writing Your First Application
tutorial provides an introduction to how to use the APIs provided by the Fabric
SDKs to invoke smart contracts from your client applications. For an in depth
overview of how Fabric applications and smart contracts work together, you
can visit the Developing Applications topic.
The Deploying a smart contract to a channel tutorial can also be used by network operators to learn
how to use the Fabric chaincode lifecycle to manage smart contracts deployed on
a running network. Both network operators and application developers can use the
tutorials on Private data and CouchDB
to explore important Fabric features. When you are ready to deploy Hyperledger
Fabric in production, see the guide for Deploying a production network.
There are two tutorials for updating a channel: Updating a channel configuration and
Updating the capability level of a channel, while Upgrading your components shows how
to upgrade components like peers, ordering nodes, SDKs, and more.
Finally, we provide an introduction to how to write a basic smart contract,
Chaincode for Developers.

Note
If you have questions not addressed by this documentation, or run into
issues with any of the tutorials, please visit the Still Have Questions?
page for some tips on where to find additional help.


Tutorials

Using the Fabric test network
Deploying a smart contract to a channel
Writing Your First Application
Commercial paper tutorial
Using Private Data in Fabric
Using CouchDB
Adding an Org to a Channel
Updating a channel configuration
Chaincode for Developers
Building Your First Network
Videos









Next 
 Previous




        © Copyright Hyperledger 2020.
    
This work is licensed under a Creative Commons Attribution 4.0 International License



          Revision 77bafd68.
        


  Built with Sphinx using a theme provided by Read the Docs. 



https://hyperledger-fabric.readthedocs.io/en/release-2.0/deployment_guide_overview.html



Docs »
Deploying a production network

 Edit on GitHub







Deploying a production networkÂ¶
This deployment guide is a high level overview of the proper sequence for setting up production Fabric network components, in addition to best practices and a few of the many considerations to keep in mind when deploying. Note that this topic will discuss âsetting up the networkâ as a holistic process from the perspective of a single individual. More likely than not, real world production networks will not be set up by a single individual but as a collaborative effort directed by several individuals (a collection of banks each setting up their own components, for example) instead.
The process for deploying a Fabric network is complex and presumes an understanding of Public Key Infrastructure and managing distributed systems. If you are a smart contract or application developer, you should not need this level of expertise in deploying a production level Fabric network. However, you might need to be aware of how networks are deployed in order to develop effective smart contracts and applications.
If all you need is a development environment to test chaincode, smart contracts, and applications against, check out Using the Fabric test network. It includes two organizations, each owning one peer, and a single ordering service organization that owns a single ordering node. This test network is not meant to provide a blueprint for deploying production components, and should not be used as such, as it makes assumptions and decisions that production deployments will not make.
The guide will give you an overview of the steps of setting up production components and a production network:

Step one: Decide on your network configuration

Step two: Set up a cluster for your resources

Step three: Set up your CAs

Step four: Use the CA to create identities and MSPs


Step five: Deploy nodes

Create a peer
Create an ordering node






Step one: Decide on your network configurationÂ¶
The structure of a blockchain network must be dictated by the use case. These fundamental business decisions will vary according to your use case, but letâs consider a few scenarios.
In contrast to development environments or proofs of concept, security, resource management, and high availability become a priority when operating in production. How many nodes do you need to satisfy high availability, and in what data centers do you wish to deploy them in to satisfy both the needs of disaster recovery and data residency? How will you ensure that your private keys and roots of trust remain secure?
In addition to the above, here is a sampling of the decisions you will need to make before deploying components:

Certificate Authority configuration.
As part of the overall decisions you have to make about your peers (how many, how many on each channel, and so on) and about your ordering service (how many nodes, who will own them), you also have to decide on how the CAs for your organization will be deployed. Production networks should be using Transport Layer Security (TLS), which will require setting up a TLS CA and using it to generate TLS certficates. This TLS CA will need to be deployed before your enrollment CA. Weâll discuss this more in Step three: Set up your CAs.
Use Organizational Units or not?
Some organizations might find it necessary to establish Organizational Units to create a separation between certain identities and MSPs created by a single CA.
Database type.
Some channels in a network might require all data to be modeled in a way CouchDB as the State Database can understand, while other networks, prioritizing speed, might decide that all peers will use LevelDB. Note that channels should not have peers that use both CouchDB and LevelDB on them, as the two database types model data slightly differently.
Channels and private data.
Some networks might decide that Channels are the best way to ensure privacy and isolation for certain transactions. Others might decide that a single channel, along with Private data, better serves their need for privacy.
Container orchestration.
Different users might also make different decisions about their container orchestration, creating separate containers for their peer process, logging for the peer, CouchDB, gRPC communications, and chaincode, while other users might decide to combine some of these processes.
Chaincode deployment method.
Users now have the option to deploy their chaincode using either the built in build and run support, a customized build and run using the External Builders and Launchers, or using an Chaincode as an external service.
Using firewalls.
In a production deployment, components belonging to one organization might need access to components from other organizations, necessitating the use of firewalls and advanced networking configuration. For example, applications using the Fabric SDK require access to all endorsing peers from all organizations and the ordering services for all channels. Similarly, peers need access to the ordering service on the channels that they are receiving new blocks from.

However and wherever your components are deployed, you will need a high degree of expertise in your management system of choice (such as Kubernetes) in order to efficiently operate your network. Similarly, the structure of the network must be designed to fit the business use case and any relevant laws and regulations government of the industry in which the network will be designed to function.
This deployment guide will not go through every iteration and potential network configuration, but does give common guidelines and rules to consider.


Step two: Set up a cluster for your resourcesÂ¶
Generally speaking, Fabric is agnostic to the method used to deploy and manage it. It is possible, for example, to deploy and manage a peer from a laptop. For a number of reasons, this is likely to be unadvisable, but there is nothing in Fabric that prohibits it.
As long as you have the ability to deploy containers, whether locally (or behind a firewall), or in a cloud, it should be possible to stand up components and connect them to each other. However, Kubernetes features a number of helpful tools that have made it a popular container management platform for deploying and managing Fabric networks. For more information about Kubernetes, check out the Kubernetes documentation. This topic will mostly limit its scope to the binaries and provide instructions that can be applied when using a Docker deployment or Kubernetes.
However and wherever you choose to deploy your components, you will need to make sure you have enough resources for the components to run effectively. The sizes you need will largely depend on your use case. If you plan to join a single peer to several high volume channels, it will need much more CPU and memory than a peer a user plans to join to a single channel. As a rough estimate, plan to dedicate approximately three times the resources to a peer as you plan to allocate to a single ordering node (as you will see below, it is recommended to deploy at least three and optimally five nodes in an ordering service). Similarly, you should need approximately a tenth of the resources for a CA as you will for a peer. You will also need to add storage to your cluster (some cloud providers may provide storage) as you cannot configure Persistent Volumes and Persistent Volume Claims without storage being set up with your cloud provider first.
By deploying a proof of concept network and testing it under load, you will have a better sense of the resources you will require.

Managing your infrastructureÂ¶
The exact methods and tools you use to manage your backend will depend on the backend you choose. However, here are some considerations worth noting.

Using secret objects to securely store important configuration files in your cluster. For information about Kubernetes secrets, check out Kubernetes secrets. You also have the option to use Hardened Security Modules (HSMs) or encrypted Persistent Volumes (PVs). Along similar lines, after deploying Fabric components, you will likely want to connect to a container on your own backend, for example using a private repo in a service like Docker Hub. In that case, you will need to code the login information in the form of a Kubernetes secret and include it in the YAML file when deploying components.
Cluster considerations and node sizing. In step 2 above, we discussed a general outline for how to think about the sizings of nodes. Your use case, as well as a robust period of development, is the only way you will truly know how how large your peers, ordering nodes, and CAs will need to be.
How you choose to mount your volumes. It is a best practice to mount the volumes relevant to your nodes external to the place where your nodes are deployed. This will allow you to reference these volumes later on (for example, restarting a node or a container that has crashed) without having to redeploy or regenerate your crypto material.
How you will monitor your resources. It is critical that you establish a strategy and method for monitoring the resources used by your individual nodes and the resources deployed to your cluster generally. As you join your peers to more channels, you will need likely need to increase its CPU and memory allocation. Similarly, you will need to make sure you have enough storage space for your state database and blockchain.




Step three: Set up your CAsÂ¶
The first component that must be deployed in a Fabric network is a CA. This is because the certificates associated with a node (not just for the node itself but also the certificates identifying who can administer the node) must be created before the node itself can be deployed. While it is not necessary to use the Fabric CA to create these certificates, the Fabric CA also creates MSP structures that are needed for components and organizations to be properly defined. If a user chooses to use a CA other than the Fabric CA, they will have to create the MSP folders themselves.

One CA (or more, if you are using intermediate CAs â more on intermediate CAs below) is used to generate (through a process called âenrollmentâ) the certificates of the admin of an organization, the MSP of that organization, and any nodes owned by that organization. This CA will also generate the certificates for any additional users. Because of its role in âenrollingâ identities, this CA is sometimes called the âenrollment CAâ or the âecert CAâ.
The other CA generates the certificates used to secure communications on Transport Layer Security (TLS). For this reason, this CA is often referred to as a âTLS CAâ. These TLS certificates are attached to actions as a way of preventing âman in the middleâ attacks. Note that the TLS CA is only used for issuing certificates for nodes and can be shut down when that activity is completed. Users have the option to use one way (client only) TLS as well as two way (server and client) TLS, with the latter also known as âmutual TLSâ. Because specifying that your network will be using TLS (which is recommended) should be decided before deploying the âenrollmentâ CA (the YAML file specifying the configuration of this CA has a field for enabling TLS), you should deploy your TLS CA first and use its root certificate when bootstrapping your enrollment CA. This TLS certificate will also be used by the fabric-ca client when connecting to the enrollment CA to enroll identities for users and nodes.

While all of the non-TLS certificates associated with an organization can be created by a single ârootâ CA (that is, a CA that is its own root of trust), for added security organizations can decide to use âintermediateâ CAs whose certificates are created by a root CA (or another intermediate CA that eventually leads back to a root CA). Because a compromise in the root CA leads to a collapse for its entire trust domain (the certs for the admins, nodes, and any CAs it has generated certificates for), intermediate CAs are a useful way to limit the exposure of the root CA. Whether you choose to use intermediate CAs will depend on the needs of your use case. They are not mandatory. Note that it is also possible to configure a Lightweight Directory Access Protocol (LDAP) to manage identities on a Fabric network for those enterprises that already have this implementation and do not want to add a layer of identity management to their existing infrastructure. The LDAP effectively pre registers all of the members of the directory and allows them to enroll based on the criteria given.
In a production network, it is recommended to deploy at least one CA per organization for enrollment purposes and another for TLS. For example, if you deploy three peers that are associated with one organization and an ordering node that is associated with an ordering organization, you will need at least four CAs. Two of the CAs will be for the peer organization (generating the enrollment and TLS certificates for the peer, admins, communications, and the folder structure of the MSP representing the organization) and the other two will be for the orderer organization. Note that users will generally only register and enroll with the enrollment CA, while nodes will register and enroll with both the enrollment CA (where the node will get its signing certificates that identify it when it attempts to sign its actions) and with the TLS CA (where it will get the TLS certificates it uses to authenticate its communications).
To install the Fabric CA client, which is used to register and enroll identities, follow the instructions in the Fabric CA Userâs Guide. Note that there are a number of configuration options when deploying a CA (the database type, for example, or whether to use LDAP).
For an example of how to setup a CA and enroll its admin, check out Setup Orderer Org CA. For an example of how to set up a TLS CA, check out Setup TLS CA. Note that bootstrapping the CA server means assigning a username and password that functions as âregisteringâ the CA admin.


Step four: Use the CA to create identities and MSPsÂ¶
After you have created your CAs, you can use them to create the certificates for the identities and components related to your organization (which is represented by an MSP). For each organization, you will need to, at a minimum:

Register and enroll an admin identity and create an MSP. After the CA that will be associated with an organization has been created, it can be used to first register an identity and then enroll it. In the first step, a username and password for the identity is assigned by the admin of the CA. Attributes and affiliations can also be given to the identity (for example, a role of admin, which is necessary for organization admins). After the identity has been registered, it can be enrolled by using the username and password. The CA will generate two certificates for this identity â a public certificate (also known as a signcert) known to the other members of the network, and the private key (stored in the keystore folder) used to sign actions taken by the identity. The CA will also generate an MSP file containing the public certificate of the CA issuing the certificate and the root of trust for the CA (this may or may not be the same CA). This MSP can be thought of as defining the organization associated with the identity of the admin. For an example of how this process looks, check out the this example of how an admin is enrolled. In cases where the admin of the org will also be an admin of a node (which will be typical), you must create the org admin identity before creating the local MSP of a node, since the certificate of the node admin must be used when creating the local MSP.
Register and enroll node identities. Just as an org admin identity is registered and enrolled, the identity of a node must be registered and enrolled with both an enrollment CA and the TLS CA. For this reason, it can be useful for your enrollment CA and TLS to share a database (which allows the node identity to only be registered once and enrolled by each CA server separately), though this is an optional configuration option. Instead of giving a node a role of admin or user when registering it with the enrollment CA, give it a role of peer or orderer. As with the admin, attributes and affiliations for this identity can also be assigned. The MSP structure for a node is known as a âlocal MSPâ, since the permissions assigned to the identities are only relevant at the local (node) level. This MSP is created when the node identity is created, and is used when bootstrapping the node. You will use the TLS root certificate generated when enrolling with the TLS CA when joining your organization to the channel (this certificate must be added to the org MSP that was created when you enrolled your admin) and when using the peer binary as a CLI client to make calls to other peers (as in peer chaincode invoke) or ordering nodes (as in peer channel fetch) because there is no orderer CLI. It is not necessary to add the TLS root certificates to the local MSP of a node because these certificates are contained in the channel configuration.

For more conceptual information about identities and permissions in a Fabric-based blockchain network, see Identity and membership/membership.html.
For a look at how to use a CA to generate an admin identity and MSP, check out Enroll Org1âs Admin.
To see how to use the enrollment CA to and the TLS CA to generate the certificates for a node, check out Setup Org1âs Peers.


Step five: Deploy nodesÂ¶
Once you have gathered all of the certificates and MSPs you need, youâre almost ready to create a node. As discussed above, there are a number of valid ways to deploy nodes.

Create a peerÂ¶
Before you can create a peer, you will need to customize the configuration file for the peer. In Fabric, this file is called core.yaml. You can find a sample core.yaml configuration file in the sampleconfig directory of Hyperledger Fabric.
As you can see in the file, there are quite a number of parameters you either have the option to set or will need to set for your node to work properly. In general, if you do not have the need to change a tuning value, leave it alone. You will, however, likely need to adjust the various addresses, specify the database type you want to use, as well as to specify where the MSP for the node is located.
You have two main options for tuning your configuration.

Edit the YAML file bundled with the binaries.
Use environment variable overrides when deploying.
Specify flags on CLI commands.

Option 1 has the advantage of persisting your changes whenever you bring down and bring back up the node. The downside is that you will have to port the options you customized to the new YAML when upgrading to a new binary version (you should use the latest YAML when upgrading to a new version).
Either way, here are some values in core.yaml you must review.

peer.localMspID: this is the name of the local MSP of your peer organization. This MSP is where your peer organization admins will be listed as well as the peer organizationâs root CA and TLS CA certificates.
peer.mspConfigPath: the place where the local MSP for the peer is located. Note that it is a best practice to mount this volume external to your container. This ensures that even if the container is stopped (for example, during a maintenance cycle) that the MSPs are not lost and have to be recreated.
peer.address: represents the endpoint to other peers in the same organization, an important consideration when establishing gossip communication within an organization.
peer.tls: When you set the enabled value to true (as should be done in a production network), you will have to specify the locations of the relevant TLS certificates. Note that all of the nodes in a network (both the peers and the ordering nodes) must either all have TLS enabled or not enabled. For production networks, it is highly recommended to enable TLS. As with your MSP, it is a best practice to mount this volume external to your container.
ledger: users have a number of decisions to make about their ledger, including the state database type (LevelDB or CouchDB, for example), and its location (specified in fileSystemPath). Note that for CouchDB in particular it is a best practice to operate your state database external to the peer, as you will be better able to allocate specific resources to the database this way.
gossip: there are a number of configuration options to think about when setting up Gossip data dissemination protocol, including the externalEndpoint (which makes peers discoverable to peers owned by other organizations) as well as the bootstrap address (which identifies a peer in the peerâs own organization).
chaincode.externalBuilders: this field is important to set when using cc_service.html.

When youâre comfortable with how your peer has been configured, how your volumes are mounted, and your backend configuration, you can run the command to launch the peer (this command will depend on your backend configuration).


Create an ordering nodeÂ¶
Unlike the creation of a peer, you will need to create a genesis block (or reference a block that has already been created, if adding an ordering node to an existing ordering service) and specify the path to it before launching the ordering node.
In Fabric, this configuration file for ordering nodes is called orderer.yaml. You can find a sample orderer.yaml configuration file in the sampleconfig directory of Hyperledger Fabric. Note that orderer.yaml is different than the âgenesis blockâ of an ordering service. This block, which includes the initial configuration of the orderer system channel, must be created before an ordering node is created because it is used to bootstrap the node.
As with the peer, you will see that there are quite a number of parameters you either have the option to set or will need to set for your node to work properly. In general, if you do not have the need to change a tuning value, leave it alone.
You have two main options for tuning your configuration.

Edit the YAML file bundled with the binaries.
Use environment variable overrides when deploying.
Specify flags on CLI commands.

Option 1 has the advantage of persisting your changes whenever you bring down and bring back up the node. The downside is that you will have to port the options you customized to the new YAML when upgrading to a new binary version (you should use the latest YAML when upgrading to a new version).
Either way, here are some values in orderer.yaml you must review. You will notice that some of these fields are the same as those in core.yaml only with different names.

General.LocalMSPID: this is the name of the local MSP, generated by your CA, of your orderer organization.
General.LocalMSPDir: the place where the local MSP for the ordering node is located. Note that it is a best practice to mount this volume external to your container.
General.ListenAddress and General.ListenPort: represents the endpoint to other ordering nodes in the same organization.
FileLedger: although ordering nodes do not have a state database, they still all carry copies of the blockchain, as this allows them to verify permissions using the latest config block. Therefore the ledger fields should be customized with the correct file path.
Cluster: these values are important for ordering service nodes that communicate with other ordering nodes, such as in a Raft based ordering service.
General.BootstrapFile: this is the name of the configuration block used to bootstrap an ordering node. If this node is the first node generated in an ordering service, this file will have to be generated and is known as the âgenesis blockâ.
General.BootstrapMethod: the method by which the bootstrap block is given. For now, this can only be file, in which the file in the BootstrapFile is specified. Starting in 2.0, you can specify none to simply start the orderer without bootstrapping.
Consensus: determines the key/value pairs allowed by the consensus plugin (Raft ordering services are supported and recommended) for the Write Ahead Logs (WALDir) and Snapshots (SnapDir).

When youâre comfortable with how your ordering node has been configured, how your volumes are mounted, and your backend configuration, you can run the command to launch the ordering node (this command will depend on your backend configuration).



Next stepsÂ¶
Blockchain networks are all about connection, so once youâve deployed nodes, youâll obviously want to connect them to other nodes! If you have a peer organization and a peer, youâll want to join your organization to a consortium and join or Channels. If you have an ordering node, you will want to add peer organizations to your consortium. Youâll also want to learn how to develop chaincode, which you can learn about in the topics The scenario and Fabric chaincode lifecycle.
Part of the process of connecting nodes and creating channels will involve modifying policies to fit the use cases of business networks. For more information about policies, check out Policies.
One of the common tasks in a Fabric will be the editing of existing channels. For a tutorial about that process, check out Updating a channel configuration. One popular channel update is to add an org to an existing channel. For a tutorial about that specific process, check out Adding an Org to a Channel. For information about upgrading nodes after they have been deployed, check out Upgrading your components.








Next 
 Previous




        © Copyright Hyperledger 2020.
    
This work is licensed under a Creative Commons Attribution 4.0 International License



          Revision 77bafd68.
        


  Built with Sphinx using a theme provided by Read the Docs. 



https://hyperledger-fabric.readthedocs.io/en/release-2.0/ops_guide.html



Docs »
Operations Guides

 Edit on GitHub







Operations GuidesÂ¶


Setting up an ordering node
Membership Service Providers (MSP)
Using a Hardware Security Module (HSM)
Channel Configuration (configtx)
Endorsement policies
Pluggable transaction endorsement and validation
Access Control Lists (ACL)
MSP Implementation with Identity Mixer
Identity Mixer MSP configuration generator (idemixgen)
The Operations Service
Metrics Reference
External Builders and Launchers
Chaincode as an external service
Error handling
Logging Control
Securing Communication With Transport Layer Security (TLS)
Configuring and operating a Raft ordering service
Migrating from Kafka to Raft
Bringing up a Kafka-based Ordering Service









Next 
 Previous




        © Copyright Hyperledger 2020.
    
This work is licensed under a Creative Commons Attribution 4.0 International License



          Revision 77bafd68.
        


  Built with Sphinx using a theme provided by Read the Docs. 



https://hyperledger-fabric.readthedocs.io/en/release-2.0/upgrade.html



Docs »
Upgrading to the latest release

 Edit on GitHub







Upgrading to the latest releaseÂ¶
If youâre familiar with previous releases of Hyperledger Fabric, youâre aware
that upgrading the nodes and channels to the latest version of Fabric is, at a
high level, a four step process.

Backup the ledger and MSPs.
Upgrade the orderer binaries in a rolling fashion to the latest Fabric version.
Upgrade the peer binaries in a rolling fashion to the latest Fabric version.
Update the orderer system channel and any application channels to the latest
capability levels, where available. Note that some releases will have
capabilities in all groups while other releases may have few or even no new
capabilities at all.

For more information about capabilities, check out Channel capabilities.
For a look at how these upgrade processes are accomplished, please consult these
tutorials:

Upgrading your components. Components should be upgraded to the latest
version before updating any capabilities.
Updating the capability level of a channel. Completed after updating the versions of all nodes.
Enabling the new chaincode lifecycle. Necessary to add organization specific endorsement
policies central to the new chaincode lifecycle for Fabric v2.0.

As the upgrading of nodes and increasing the capability levels of channels is by
now considered a standard Fabric process, we will not show the specific commands
for upgrading to the newest release. Similarly, there is no script in the fabric-samples
repo that will upgrade a sample network from the previous release to this one,
as there has been for previous releases.

Note
It is a best practice to upgrade your SDK to the latest version as a
part of a general upgrade of your network. While the SDK will always
be compatible with equivalent releases of Fabric and lower, it might
be necessary to upgrade to the latest SDK to leverage the latest Fabric
features. Consult the documentation of the Fabric SDK you are using
for information about how to upgrade.


Upgrading to the latest release

Considerations for getting to v2.0
Upgrading your components
Updating the capability level of a channel
Enabling the new chaincode lifecycle









Next 
 Previous




        © Copyright Hyperledger 2020.
    
This work is licensed under a Creative Commons Attribution 4.0 International License



          Revision 77bafd68.
        


  Built with Sphinx using a theme provided by Read the Docs. 



https://hyperledger-fabric.readthedocs.io/en/release-2.0/command_ref.html



Docs »
Commands Reference

 Edit on GitHub







Commands ReferenceÂ¶


peer
peer chaincode
peer lifecycle chaincode
peer channel
peer version
peer node
configtxgen
configtxlator
cryptogen
Service Discovery CLI
Fabric-CA Commands









Next 
 Previous




        © Copyright Hyperledger 2020.
    
This work is licensed under a Creative Commons Attribution 4.0 International License



          Revision 77bafd68.
        


  Built with Sphinx using a theme provided by Read the Docs. 



https://hyperledger-fabric.readthedocs.io/en/release-2.0/architecture.html



Docs »
Architecture Reference

 Edit on GitHub







Architecture ReferenceÂ¶


Hyperledger Fabric CA's User Guide
Hyperledger Fabric SDKs
Transaction Flow
Service Discovery
Defining capability requirements
Channels
CouchDB as the State Database
Peer channel-based event services
Private Data
Read-Write set semantics
Gossip data dissemination protocol









Next 
 Previous




        © Copyright Hyperledger 2020.
    
This work is licensed under a Creative Commons Attribution 4.0 International License



          Revision 77bafd68.
        


  Built with Sphinx using a theme provided by Read the Docs. 



https://hyperledger-fabric.readthedocs.io/en/release-2.0/Fabric-FAQ.html



Docs »
Frequently Asked Questions

 Edit on GitHub







Frequently Asked QuestionsÂ¶

EndorsementÂ¶
Endorsement architecture:




Question:How many peers in the network need to endorse a transaction?

Answer:The number of peers required to endorse a transaction is driven by the
endorsement policy that is specified in the chaincode definition.

Question:Does an application client need to connect to all peers?

Answer:Clients only need to connect to as many peers as are required by the
endorsement policy for the chaincode.





Security & Access ControlÂ¶




Question:How do I ensure data privacy?


Answer:There are various aspects to data privacy. First, you can segregate your
network into channels, where each channel represents a subset of participants
that are authorized to see the data for the chaincodes that are deployed to
that channel.
Second, you can use private-data to keep ledger data private from
other organizations on the channel. A private data collection allows a
defined subset of organizations on a channel the ability to endorse, commit,
or query private data without having to create a separate channel.
Other participants on the channel receive only a hash of the data.
For more information refer to the Using Private Data in Fabric tutorial.
Note that the key concepts topic also explains when to use private data instead of a channel.
Third, as an alternative to Fabric hashing the data using private data,
the client application can hash or encrypt the data before calling
chaincode. If you hash the data then you will need to provide a means to
share the source data. If you encrypt the data then you will need to provide
a means to share the decryption keys.
Fourth, you can restrict data access to certain roles in your organization, by
building access control into the chaincode logic.
Fifth, ledger data at rest can be encrypted via file system encryption on the
peer, and data in-transit is encrypted via TLS.


Question:Do the orderers see the transaction data?


Answer:No, the orderers only order transactions, they do not open the transactions.
If you do not want the data to go through the orderers at all, then utilize
the private data feature of Fabric.  Alternatively, you can hash or encrypt
the data in the client application before calling chaincode. If you encrypt
the data then you will need to provide a means to share the decryption keys.






Application-side Programming ModelÂ¶




Question:How do application clients know the outcome of a transaction?


Answer:The transaction simulation results are returned to the client by the
endorser in the proposal response.  If there are multiple endorsers, the
client can check that the responses are all the same, and submit the results
and endorsements for ordering and commitment. Ultimately the committing peers
will validate or invalidate the transaction, and the client becomes
aware of the outcome via an event, that the SDK makes available to the
application client.


Question:How do I query the ledger data?


Answer:Within chaincode you can query based on keys. Keys can be queried by range,
and composite keys can be modeled to enable equivalence queries against
multiple parameters. For example a composite key of (owner,asset_id) can be
used to query all assets owned by a certain entity. These key-based queries
can be used for read-only queries against the ledger, as well as in
transactions that update the ledger.
If you model asset data as JSON in chaincode and use CouchDB as the state
database, you can also perform complex rich queries against the chaincode
data values, using the CouchDB JSON query language within chaincode. The
application client can perform read-only queries, but these responses are
not typically submitted as part of transactions to the ordering service.


Question:How do I query the historical data to understand data provenance?


Answer:The chaincode API GetHistoryForKey() will return history of
values for a key.


Question:How to guarantee the query result is correct, especially when the peer being
queried may be recovering and catching up on block processing?


Answer:The client can query multiple peers, compare their block heights, compare
their query results, and favor the peers at the higher block heights.






Chaincode (Smart Contracts and Digital Assets)Â¶




Question:Does Hyperledger Fabric support smart contract logic?


Answer:Yes. We call this feature Chaincode. It is our interpretation of the
smart contract method/algorithm, with additional features.
A chaincode is programmatic code deployed on the network, where it is
executed and validated by chain validators together during the consensus
process. Developers can use chaincodes to develop business contracts,
asset definitions, and collectively-managed decentralized applications.


Question:How do I create a business contract?


Answer:There are generally two ways to develop business contracts: the first way is
to code individual contracts into standalone instances of chaincode; the
second way, and probably the more efficient way, is to use chaincode to
create decentralized applications that manage the life cycle of one or
multiple types of business contracts, and let end users instantiate
instances of contracts within these applications.


Question:How do I create assets?


Answer:Users can use chaincode (for business rules) and membership service (for
digital tokens) to design assets, as well as the logic that manages them.
There are two popular approaches to defining assets in most blockchain
solutions: the stateless UTXO model, where account balances are encoded
into past transaction records; and the account model, where account
balances are kept in state storage space on the ledger.
Each approach carries its own benefits and drawbacks. This blockchain
technology does not advocate either one over the other. Instead, one of our
first requirements was to ensure that both approaches can be easily
implemented.


Question:Which languages are supported for writing chaincode?


Answer:Chaincode can be written in any programming language and executed in
containers. Currently, Golang, node.js and java chaincode are supported.


Question:Does the Hyperledger Fabric have native currency?


Answer:No. However, if you really need a native currency for your chain network,
you can develop your own native currency with chaincode. One common attribute
of native currency is that some amount will get transacted (the chaincode
defining that currency will get called) every time a transaction is processed
on its chain.






Differences in Most Recent ReleasesÂ¶




Question:Where can I find what  are the highlighted differences between releases?

Answer:The differences between any subsequent releases are provided together with
the Releases.

Question:Where to get help for the technical questions not answered above?

Answer:Please use StackOverflow.





Ordering ServiceÂ¶




Question:I have an ordering service up and running and want to switch consensus
algorithms. How do I do that?

Answer:This is explicitly not supported.







Question:What is the orderer system channel?

Answer:The orderer system channel (sometimes called ordering system channel) is the
channel the orderer is initially bootstrapped with. It is used to orchestrate
channel creation. The orderer system channel defines consortia and the initial
configuration for new channels. At channel creation time, the organization
definition in the consortium, the /Channel groupâs values and policies, as
well as the /Channel/Orderer groupâs values and policies, are all combined
to form the new initial channel definition.







Question:If I update my application channel, should I update my orderer system
channel?

Answer:Once an application channel is created, it is managed independently of any
other channel (including the orderer system channel). Depending on the
modification, the change may or may not be desirable to port to other
channels. In general, MSP changes should be synchronized across all channels,
while policy changes are more likely to be specific to a particular channel.







Question:Can I have an organization act both in an ordering and application role?

Answer:Although this is possible, it is a highly discouraged configuration. By
default the /Channel/Orderer/BlockValidation policy allows any valid
certificate of the ordering organizations to sign blocks. If an organization
is acting both in an ordering and application role, then this policy should be
updated to restrict block signers to the subset of certificates authorized for
ordering.







Question:I want to write a consensus implementation for Fabric. Where do I begin?

Answer:A consensus plugin needs to implement the Consenter and Chain
interfaces defined in the consensus package. There is a plugin built
against raft . You can study it to learn more for your own implementation. The ordering service code can be found under
the orderer package.







Question:I want to change my ordering service configurations, e.g. batch timeout,
after I start the network, what should I do?

Answer:This falls under reconfiguring the network. Please consult the topic on
configtxlator.




BFTÂ¶




Question:When is a BFT version of the ordering service going to be available?

Answer:No date has been set. We are working towards a release during the 1.x cycle,
i.e. it will come with a minor version upgrade in Fabric. Track FAB-33 for
updates.












Next 
 Previous




        © Copyright Hyperledger 2020.
    
This work is licensed under a Creative Commons Attribution 4.0 International License



          Revision 77bafd68.
        


  Built with Sphinx using a theme provided by Read the Docs. 



https://hyperledger-fabric.readthedocs.io/en/release-2.0/CONTRIBUTING.html



Docs »
Contributions Welcome!

 Edit on GitHub







Note
Users who are migrating from Gerrit to GitHub: You can follow simple
Git workflows to move your development from Gerrit to GitHub. After
forking the Fabric repo, simply push the branches you want to save from
your current Gerrit-based local repo to your remote forked repository.
Once youâve pushed the changes you want to save, simply delete your
local Gerrit-based repository and clone your fork.
For a basic Git workflow recommendation please see our doc at
GitHub Contributions.


Contributions Welcome!Â¶
We welcome contributions to Hyperledger in many forms, and
thereâs always plenty to do!
First things first, please review the Hyperledger Code of
Conduct
before participating. It is important that we keep things civil.

Ways to contributeÂ¶
There are many ways you can contribute to Hyperledger Fabric, both as a user and
as a developer.
As a user:

Making Feature/Enhancement Proposals
Reporting bugs
Help test an upcoming Epic on the
release roadmap.
Contact the Epic assignee via the Jira work item or on
RocketChat.

As a developer:

If you only have a little time, consider picking up a
âhelp-wantedâ task,
see Fixing issues and working stories.
If you can commit to full-time development, either propose a new feature
(see Making Feature/Enhancement Proposals) and
bring a team to implement it, or join one of the teams working on an existing Epic.
If you see an Epic that interests you on the
release roadmap,
contact the Epic assignee via the Jira work item or on RocketChat.



Getting a Linux Foundation accountÂ¶
In order to participate in the development of the Hyperledger Fabric
project, you will need a Linux Foundation
account. Once you have a LF ID you will be able to
access all the Hyperledger community tools, including
Jira issue management,
RocketChat, and the
Wiki (for editing, only).
Follow the steps below to create a Linux Foundation account if you donât
already have one.

Go to the Linux Foundation ID
website.
Select the option I need to create a Linux Foundation ID, and fill
out the form that appears.
Wait a few minutes, then look for an email message with the subject line:
âValidate your Linux Foundation ID emailâ.
Open the received URL to validate your email address.
Verify that your browser displays the message
You have successfully validated your e-mail address.
Access Jira issue management, or
RocketChat.



Project GovernanceÂ¶
Hyperledger Fabric is managed under an open governance model as described in
our charter. Projects and
sub-projects are lead by a set of maintainers. New sub-projects can
designate an initial set of maintainers that will be approved by the
top-level projectâs existing maintainers when the project is first
approved.

MaintainersÂ¶
The Fabric project is lead by the projectâs top level maintainers.
The maintainers are responsible for reviewing and merging all patches submitted
for review, and they guide the overall technical direction of the project within
the guidelines established by the Hyperledger Technical Steering Committee (TSC).


Becoming a maintainerÂ¶
The projectâs maintainers will, from time-to-time, consider
adding or removing a maintainer. An existing maintainer can submit a
change set to the maintainers file. A nominated
Contributor may become a Maintainer by a majority approval of the proposal
by the existing Maintainers. Once approved, the change set is then merged
and the individual is added to (or alternatively, removed from) the maintainers
group. Maintainers may be removed by explicit resignation, for prolonged
inactivity (3 or more months), or for some infraction of the code of conduct
or by consistently demonstrating poor judgement. A maintainer removed for
inactivity should be restored following a sustained resumption of contributions
and reviews (a month or more) demonstrating a renewed commitment to the project.


Release cadenceÂ¶
The Fabric maintainers have settled on a quarterly (approximately) release
cadence (see releases).
At any given time, there will be a stable LTS (long term support) release branch,
as well as the master branch for upcoming new features.
Follow the discussion on the #fabric-release channel in RocketChat.


Making Feature/Enhancement ProposalsÂ¶
First, take time to review
JIRA
to be sure that there isnât already an open (or recently closed) proposal for the
same function. If there isnât, to make a proposal we recommend that you open a
JIRA Epic or Story, whichever seems to best fit the circumstance and
link or inline a âone pagerâ of the proposal that states what the feature would
do and, if possible, how it might be implemented. It would help also to make a
case for why the feature should be added, such as identifying specific use
case(s) for which the feature is needed and a case for what the benefit would be
should the feature be implemented. Once the JIRA issue is created, and the
âone pagerâ either attached, inlined in the description field, or a link to a
publicly accessible document is added to the description, send an introductory
email to the fabric@lists.hyperledger.org mailing list linking the
JIRA issue, and soliciting feedback.
Discussion of the proposed feature should be conducted in the JIRA issue itself,
so that we have a consistent pattern within our community as to where to find
design discussion.
Getting the support of three or more of the Hyperledger Fabric maintainers for
the new feature will greatly enhance the probability that the featureâs related
PRs will be included in a subsequent release.


Maintainers meetingÂ¶
The maintainers hold regular maintainers meetings.
The purpose of the maintainers meeting is to plan for and review the progress of
releases, and to discuss the technical and operational direction of the project
and sub-projects.
Please see the
wiki
for maintainer meeting details.
New feature/enhancement proposals as described above should be presented to a
maintainers meeting for consideration, feedback and acceptance.


Release roadmapÂ¶
The Fabric release roadmap of epics is maintained in
JIRA.


CommunicationsÂ¶
We use RocketChat for communication
and Google Hangoutsâ¢ for screen sharing between developers. Our
development planning and prioritization is done in
JIRA, and we take longer running
discussions/decisions to the mailing
list.



Contribution guideÂ¶

Install prerequisitesÂ¶
Before we begin, if you havenât already done so, you may wish to check that
you have all the prerequisites installed on the platform(s)
on which youâll be developing blockchain applications and/or operating
Hyperledger Fabric.


Getting helpÂ¶
If you are looking for something to work on, or need some expert
assistance in debugging a problem or working out a fix to an issue, our
community is always eager to
help. We hang out on
Chat, IRC
(#hyperledger on freenode.net) and the mailing
lists. Most of us donât bite :grin:
and will be glad to help. The only silly question is the one you donât
ask. Questions are in fact a great way to help improve the project as
they highlight where our documentation could be clearer.


Reporting bugsÂ¶
If you are a user and you have found a bug, please submit an issue using
JIRA.
Before you create a new JIRA issue, please try to search the existing items to
be sure no one else has previously reported it. If it has been previously
reported, then you might add a comment that you also are interested in seeing
the defect fixed.

Note
If the defect is security-related, please follow the Hyperledger
security bug reporting process.

If it has not been previously reported, you may either submit a PR with a
well documented commit message describing the defect and the fix, or you
may create a new JIRA. Please try to provide
sufficient information for someone else to reproduce the
issue. One of the projectâs maintainers should respond to your issue within 24
hours. If not, please bump the issue with a comment and request that it be
reviewed. You can also post to the relevant Hyperledger Fabric channel in
Hyperledger Chat.  For example, a doc bug should
be broadcast to #fabric-documentation, a database bug to #fabric-ledger,
and so onâ¦


Submitting your fixÂ¶
If you just submitted a JIRA for a bug youâve discovered, and would like to
provide a fix, we would welcome that gladly! Please assign the JIRA issue to
yourself, then submit a pull request (PR). Please refer to GitHub Contributions
for a detailed workflow.


Fixing issues and working storiesÂ¶
Review the issues
list and find
something that interests you. You could also check the
âhelp-wantedâ
list. It is wise to start with something relatively straight forward and
achievable, and that no one is already assigned. If no one is assigned,
then assign the issue to yourself. Please be considerate and rescind the
assignment if you cannot finish in a reasonable time, or add a comment
saying that you are still actively working the issue if you need a
little more time.


Reviewing submitted Pull Requests (PRs)Â¶
Another way to contribute and learn about Hyperledger Fabric is to help the
maintainers with the review of the PRs that are open. Indeed
maintainers have the difficult role of having to review all the PRs
that are being submitted and evaluate whether they should be merged or
not. You can review the code and/or documentation changes, test the
changes, and tell the submitters and maintainers what you think. Once
your review and/or test is complete just reply to the PR with your
findings, by adding comments and/or voting. A comment saying something
like âI tried it on system X and it worksâ or possibly âI got an error
on system X: xxx â will help the maintainers in their evaluation. As a
result, maintainers will be able to process PRs faster and everybody
will gain from it.
Just browse through the open PRs on GitHub to get started.


PR AgingÂ¶
As the Fabric project has grown, so too has the backlog of open PRs. One
problem that nearly all projects face is effectively managing that backlog
and Fabric is no exception. In an effort to keep the backlog of Fabric and
related project PRs manageable, we are introducing an aging policy which
will be enforced by bots.  This is consistent with how other large projects
manage their PR backlog.


PR Aging PolicyÂ¶
The Fabric project maintainers will automatically monitor all PR activity for
delinquency. If a PR has not been updated in 2 weeks, a reminder comment will be
added requesting that the PR either be updated to address any outstanding
comments or abandoned if it is to be withdrawn. If a delinquent PR goes another
2 weeks without an update, it will be automatically abandoned. If a PR has aged
more than 2 months since it was originally submitted, even if it has activity,
it will be flagged for maintainer review.
If a submitted PR has passed all validation but has not been reviewed in 72
hours (3 days), it will be flagged to the #fabric-pr-review channel daily until
it receives a review comment(s).
This policy applies to all official Fabric projects (fabric, fabric-ca,
fabric-samples, fabric-test, fabric-sdk-node, fabric-sdk-java, fabric-gateway-java,
fabric-chaincode-node, fabric-chaincode-java, fabric-chaincode-evm,
fabric-baseimage, and fabric-amcl).


Setting up development environmentÂ¶
Next, try building the project in your local
development environment to ensure that everything is set up correctly.


What makes a good pull request?Â¶

One change at a time. Not five, not three, not ten. One and only one.
Why? Because it limits the blast area of the change. If we have a
regression, it is much easier to identify the culprit commit than if
we have some composite change that impacts more of the code.
Include a link to the JIRA story for the change. Why? Because a) we
want to track our velocity to better judge what we think we can
deliver and when and b) because we can justify the change more
effectively. In many cases, there should be some discussion around a
proposed change and we want to link back to that from the change
itself.
Include unit and integration tests (or changes to existing tests)
with every change. This does not mean just happy path testing,
either. It also means negative testing of any defensive code that it
correctly catches input errors. When you write code, you are
responsible to test it and provide the tests that demonstrate that
your change does what it claims. Why? Because without this we have no
clue whether our current code base actually works.
Unit tests should have NO external dependencies. You should be able
to run unit tests in place with go test or equivalent for the
language. Any test that requires some external dependency (e.g. needs
to be scripted to run another component) needs appropriate mocking.
Anything else is not unit testing, it is integration testing by
definition. Why? Because many open source developers do Test Driven
Development. They place a watch on the directory that invokes the
tests automagically as the code is changed. This is far more
efficient than having to run a whole build between code changes. See
this definition
of unit testing for a good set of criteria to keep in mind for writing
effective unit tests.
Minimize the lines of code per PR. Why? Maintainers have day jobs,
too. If you send a 1,000 or 2,000 LOC change, how long do you think
it takes to review all of that code? Keep your changes to < 200-300
LOC, if possible. If you have a larger change, decompose it into
multiple independent changes. If you are adding a bunch of new
functions to fulfill the requirements of a new capability, add them
separately with their tests, and then write the code that uses them
to deliver the capability. Of course, there are always exceptions. If
you add a small change and then add 300 LOC of tests, you will be
forgiven;-) If you need to make a change that has broad impact or a
bunch of generated code (protobufs, etc.). Again, there can be
exceptions.


Note
Large pull requests, e.g. those with more than 300 LOC are more than likely
not going to receive an approval, and youâll be asked to refactor
the change to conform with this guidance.


Write a meaningful commit message. Include a meaningful 55 (or less)
character title, followed by a blank line, followed by a more
comprehensive description of the change. Each change MUST include the JIRA
identifier corresponding to the change (e.g. [FAB-1234]). This can be
in the title but should also be in the body of the commit message.


Note
Example commit message:
[FAB-1234] fix foobar() panic

Fix [FAB-1234] added a check to ensure that when foobar(foo string)
is called, that there is a non-empty string argument.



Finally, be responsive. Donât let a pull request fester with review
comments such that it gets to a point that it requires a rebase. It only
further delays getting it merged and adds more work for you - to
remediate the merge conflicts.



Legal stuffÂ¶
Note: Each source file must include a license header for the Apache
Software License 2.0. See the template of the license header.
We have tried to make it as easy as possible to make contributions. This
applies to how we handle the legal aspects of contribution. We use the
same approachâthe Developerâs Certificate of Origin 1.1
(DCO)âthat the LinuxÂ® Kernel
community uses
to manage code contributions.
We simply ask that when submitting a patch for review, the developer
must include a sign-off statement in the commit message.
Here is an example Signed-off-by line, which indicates that the
submitter accepts the DCO:
Signed-off-by: John Doe <john.doe@example.com>


You can include this automatically when you commit a change to your
local git repository using git commit -s.


Related TopicsÂ¶


Using Jira to understand current work items
Setting up the development environment
Building Hyperledger Fabric
Configuration
Coding guidelines
Generating gRPC code
Adding or updating Go packages










Next 
 Previous




        © Copyright Hyperledger 2020.
    
This work is licensed under a Creative Commons Attribution 4.0 International License



          Revision 77bafd68.
        


  Built with Sphinx using a theme provided by Read the Docs. 



https://hyperledger-fabric.readthedocs.io/en/release-2.0/glossary.html



Docs »
Glossary

 Edit on GitHub







GlossaryÂ¶
Terminology is important, so that all Hyperledger Fabric users and developers
agree on what we mean by each specific term. What is a smart contract for
example. The documentation will reference the glossary as needed, but feel free
to read the entire thing in one sitting if you like; itâs pretty enlightening!

Anchor PeerÂ¶
Used by gossip to make sure peers in different organizations know about each other.
When a configuration block that contains an update to the anchor peers is committed,
peers reach out to the anchor peers and learn from them about all of the peers known
to the anchor peer(s). Once at least one peer from each organization has contacted an
anchor peer, the anchor peer learns about every peer in the channel. Since gossip
communication is constant, and because peers always ask to be told about the existence
of any peer they donât know about, a common view of membership can be established for
a channel.
For example, letâs assume we have three organizations â A, B, C â in the channel
and a single anchor peer â peer0.orgC â defined for organization C.
When peer1.orgA (from organization A) contacts peer0.orgC, it will
tell peer0.orgC about peer0.orgA. And when at a later time peer1.orgB
contacts peer0.orgC, the latter would tell the former about peer0.orgA.
From that point forward, organizations A and B would start exchanging
membership information directly without any assistance from peer0.orgC.
As communication across organizations depends on gossip in order to work, there must
be at least one anchor peer defined in the channel configuration. It is strongly
recommended that every organization provides its own set of anchor peers for high
availability and redundancy.


ACLÂ¶
An ACL, or Access Control List, associates access to specific peer
resources (such as system chaincode APIs or event services) to a Policy
(which specifies how many and what types of organizations or roles are
required). The ACL is part of a channelâs configuration. It is therefore
persisted in the channelâs configuration blocks, and can be updated using the
standard configuration update mechanism.
An ACL is formatted as a list of key-value pairs, where the key identifies
the resource whose access we wish to control, and the value identifies the
channel policy (group) that is allowed to access it. For example
lscc/GetDeploymentSpec: /Channel/Application/Readers
defines that the access to the life cycle chaincode GetDeploymentSpec API
(the resource) is accessible by identities which satisfy the
/Channel/Application/Readers policy.
A set of default ACLs is provided in the configtx.yaml file which is
used by configtxgen to build channel configurations. The defaults can be set
in the top level âApplicationâ section of configtx.yaml or overridden
on a per profile basis in the âProfilesâ section.


BlockÂ¶


Block B1 is linked to block B0. Block B2 is linked to block B1.


A block contains an ordered set of transactions. It is cryptographically linked
to the preceding block, and in turn it is linked to be subsequent blocks. The
first block in such a chain of blocks is called the genesis block. Blocks
are created by the ordering service, and then validated and committed by peers.


ChainÂ¶


Blockchain B contains blocks 0, 1, 2.


The ledgerâs chain is a transaction log structured as hash-linked blocks of
transactions. Peers receive blocks of transactions from the ordering service, mark
the blockâs transactions as valid or invalid based on endorsement policies and
concurrency violations, and append the block to the hash chain on the peerâs
file system.


ChaincodeÂ¶
See Smart-Contract.


ChannelÂ¶


Channel C connects application A1, peer P2 and ordering service O1.


A channel is a private blockchain overlay which allows for data
isolation and confidentiality. A channel-specific ledger is shared across the
peers in the channel, and transacting parties must be authenticated to
a channel in order to interact with it.  Channels are defined by a
Configuration-Block.


CommitÂ¶
Each Peer on a channel validates ordered blocks of
transactions and then commits (writes/appends) the blocks to its replica of the
channel Ledger. Peers also mark each transaction in each block
as valid or invalid.


Concurrency Control Version CheckÂ¶
Concurrency Control Version Check is a method of keeping ledger state in sync across
peers on a channel. Peers execute transactions in parallel, and before committing
to the ledger, peers check whether the state read at the time the transaction was executed
has been modified. If the data read for the transaction has changed between execution time and
commit time, then a Concurrency Control Version Check violation has
occurred, and the transaction is marked as invalid on the ledger and values
are not updated in the state database.


Configuration BlockÂ¶
Contains the configuration data defining members and policies for a system
chain (ordering service) or channel. Any configuration modifications to a
channel or overall network (e.g. a member leaving or joining) will result
in a new configuration block being appended to the appropriate chain. This
block will contain the contents of the genesis block, plus the delta.


ConsensusÂ¶
A broader term overarching the entire transactional flow, which serves to generate
an agreement on the order and to confirm the correctness of the set of transactions
constituting a block.


Consenter setÂ¶
In a Raft ordering service, these are the ordering nodes actively participating
in the consensus mechanism on a channel. If other ordering nodes exist on the
system channel, but are not a part of a channel, they are not part of that
channelâs consenter set.


ConsortiumÂ¶
A consortium is a collection of non-orderer organizations on the blockchain
network. These are the organizations that form and join channels and that own
peers. While a blockchain network can have multiple consortia, most blockchain
networks have a single consortium. At channel creation time, all organizations
added to the channel must be part of a consortium. However, an organization
that is not defined in a consortium may be added to an existing channel.


Chaincode definitionÂ¶
A chaincode definition is used by organizations to agree on the parameters of a
chaincode before it can be used on a channel. Each channel member that wants to
use the chaincode to endorse transactions or query the ledger needs to approve
a chaincode definition for their organization. Once enough channel members have
approved a chaincode definition to meet the Lifecycle Endorsement policy (which
is set to a majority of organizations in the channel by default), the chaincode
definition can be committed to the channel. After the definition is committed,
the first invoke of the chaincode (or, if requested, the execution of the Init
function) will start the chaincode on the channel.


Dynamic MembershipÂ¶
Hyperledger Fabric supports the addition/removal of members, peers, and ordering service
nodes, without compromising the operationality of the overall network. Dynamic
membership is critical when business relationships adjust and entities need to
be added/removed for various reasons.


EndorsementÂ¶
Refers to the process where specific peer nodes execute a chaincode transaction and return
a proposal response to the client application. The proposal response includes the
chaincode execution response message, results (read set and write set), and events,
as well as a signature to serve as proof of the peerâs chaincode execution.
Chaincode applications have corresponding endorsement policies, in which the endorsing
peers are specified.


Endorsement policyÂ¶
Defines the peer nodes on a channel that must execute transactions attached to a
specific chaincode application, and the required combination of responses (endorsements).
A policy could require that a transaction be endorsed by a minimum number of
endorsing peers, a minimum percentage of endorsing peers, or by all endorsing
peers that are assigned to a specific chaincode application. Policies can be
curated based on the application and the desired level of resilience against
misbehavior (deliberate or not) by the endorsing peers. A transaction that is submitted
must satisfy the endorsement policy before being marked as valid by committing peers.


FollowerÂ¶
In a leader based consensus protocol, such as Raft, these are the nodes which
replicate log entries produced by the leader. In Raft, the followers also receive
âheartbeatâ messages from the leader. In the event that the leader stops sending
those message for a configurable amount of time, the followers will initiate a
leader election and one of them will be elected leader.


Genesis BlockÂ¶
The configuration block that initializes the ordering service, or serves as the
first block on a chain.


Gossip ProtocolÂ¶
The gossip data dissemination protocol performs three functions:
1) manages peer discovery and channel membership;
2) disseminates ledger data across all peers on the channel;
3) syncs ledger state across all peers on the channel.
Refer to the Gossip topic for more details.


Hyperledger Fabric CAÂ¶
Hyperledger Fabric CA is the default Certificate Authority component, which
issues PKI-based certificates to network member organizations and their users.
The CA issues one root certificate (rootCert) to each member and one enrollment
certificate (ECert) to each authorized user.


InitÂ¶
A method to initialize a chaincode application. All chaincodes need to have an
an Init function. By default, this function is never executed. However you can
use the chaincode definition to request the execution of the Init function in
order to initialize the chaincode.


InstallÂ¶
The process of placing a chaincode on a peerâs file system.


InstantiateÂ¶
The process of starting and initializing a chaincode application on a specific
channel. After instantiation, peers that have the chaincode installed can accept
chaincode invocations.
NOTE: This method i.e. Instantiate was used in the 1.4.x and older versions of the chaincode
lifecycle. For the current procedure used to start a chaincode on a channel with
the new Fabric chaincode lifecycle introduced as part of Fabric v2.0,
see Chaincode-definition_.


InvokeÂ¶
Used to call chaincode functions. A client application invokes chaincode by
sending a transaction proposal to a peer. The peer will execute the chaincode
and return an endorsed proposal response to the client application. The client
application will gather enough proposal responses to satisfy an endorsement policy,
and will then submit the transaction results for ordering, validation, and commit.
The client application may choose not to submit the transaction results. For example
if the invoke only queried the ledger, the client application typically would not
submit the read-only transaction, unless there is desire to log the read on the ledger
for audit purpose. The invoke includes a channel identifier, the chaincode function to
invoke, and an array of arguments.


LeaderÂ¶
In a leader based consensus protocol, like Raft, the leader is responsible for
ingesting new log entries, replicating them to follower ordering nodes, and
managing when an entry is considered committed. This is not a special type
of orderer. It is only a role that an orderer may have at certain times, and
then not others, as circumstances determine.


Leading PeerÂ¶
Each Organization can own multiple peers on each channel that
they subscribe to. One or more of these peers should serve as the leading peer
for the channel, in order to communicate with the network ordering service on
behalf of the organization. The ordering service delivers blocks to the
leading peer(s) on a channel, who then distribute them to other peers within
the same organization.


LedgerÂ¶


A Ledger, âLâ

A ledger consists of two distinct, though related, parts â a âblockchainâ and
the âstate databaseâ, also known as âworld stateâ. Unlike other ledgers,
blockchains are immutable â that is, once a block has been added to the
chain, it cannot be changed. In contrast, the âworld stateâ is a database
containing the current value of the set of key-value pairs that have been added,
modified or deleted by the set of validated and committed transactions in the
blockchain.
Itâs helpful to think of there being one logical ledger for each channel in
the network. In reality, each peer in a channel maintains its own copy of the
ledger â which is kept consistent with every other peerâs copy through a
process called consensus. The term Distributed Ledger Technology
(DLT) is often associated with this kind of ledger â one that is logically
singular, but has many identical copies distributed across a set of network
nodes (peers and the ordering service).


Log entryÂ¶
The primary unit of work in a Raft ordering service, log entries are distributed
from the leader orderer to the followers. The full sequence of such entries known
as the âlogâ. The log is considered to be consistent if all members agree on the
entries and their order.


MemberÂ¶
See Organization.


Membership Service ProviderÂ¶


An MSP, âORG.MSPâ

The Membership Service Provider (MSP) refers to an abstract component of the
system that provides credentials to clients, and peers for them to participate
in a Hyperledger Fabric network. Clients use these credentials to authenticate
their transactions, and peers use these credentials to authenticate transaction
processing results (endorsements). While strongly connected to the transaction
processing components of the systems, this interface aims to have membership
services components defined, in such a way that alternate implementations of
this can be smoothly plugged in without modifying the core of transaction
processing components of the system.


Membership ServicesÂ¶
Membership Services authenticates, authorizes, and manages identities on a
permissioned blockchain network. The membership services code that runs in peers
and orderers both authenticates and authorizes blockchain operations.  It is a
PKI-based implementation of the Membership Services Provider (MSP) abstraction.


Ordering ServiceÂ¶
Also known as orderer. A defined collective of nodes that orders transactions into a block
and then distributes blocks to connected peers for validation and commit. The ordering service
exists independent of the peer processes and orders transactions on a first-come-first-serve basis
for all channels on the network.  It is designed to support pluggable implementations beyond the
out-of-the-box Kafka and Raft varieties. It is a common binding for the overall network; it
contains the cryptographic identity material tied to each Member.


OrganizationÂ¶



An organization, âORGâ

Also known as âmembersâ, organizations are invited to join the blockchain network
by a blockchain network provider. An organization is joined to a network by adding its
Membership Service Provider (MSP) to the network. The MSP defines how other members of the
network may verify that signatures (such as those over transactions) were generated by a valid
identity, issued by that organization. The particular access rights of identities within an MSP
are governed by policies which are also agreed upon when the organization is joined to the
network. An organization can be as large as a multi-national corporation or as small as an
individual. The transaction endpoint of an organization is a Peer. A collection of organizations
form a Consortium. While all of the organizations on a network are members, not every organization
will be part of a consortium.


PeerÂ¶


A peer, âPâ

A network entity that maintains a ledger and runs chaincode containers in order to perform
read/write operations to the ledger.  Peers are owned and maintained by members.


PolicyÂ¶
Policies are expressions composed of properties of digital identities, for
example: Org1.Peer OR Org2.Peer. They are used to restrict access to
resources on a blockchain network. For instance, they dictate who can read from
or write to a channel, or who can use a specific chaincode API via an ACL.
Policies may be defined in configtx.yaml prior to bootstrapping an ordering
service or creating a channel, or they can be specified when instantiating
chaincode on a channel. A default set of policies ship in the sample
configtx.yaml which will be appropriate for most networks.


Private DataÂ¶
Confidential data that is stored in a private database on each authorized peer,
logically separate from the channel ledger data. Access to this data is
restricted to one or more organizations on a channel via a private data
collection definition. Unauthorized organizations will have a hash of the
private data on the channel ledger as evidence of the transaction data. Also,
for further privacy, hashes of the private data go through the
Ordering-Service, not the private data itself, so this keeps private data
confidential from Orderer.


Private Data Collection (Collection)Â¶
Used to manage confidential data that two or more organizations on a channel
want to keep private from other organizations on that channel. The collection
definition describes a subset of organizations on a channel entitled to store
a set of private data, which by extension implies that only these organizations
can transact with the private data.


ProposalÂ¶
A request for endorsement that is aimed at specific peers on a channel. Each
proposal is either an Init or an Invoke (read/write) request.


QueryÂ¶
A query is a chaincode invocation which reads the ledger current state but does
not write to the ledger. The chaincode function may query certain keys on the ledger,
or may query for a set of keys on the ledger. Since queries do not change ledger state,
the client application will typically not submit these read-only transactions for ordering,
validation, and commit. Although not typical, the client application can choose to
submit the read-only transaction for ordering, validation, and commit, for example if the
client wants auditable proof on the ledger chain that it had knowledge of specific ledger
state at a certain point in time.


QuorumÂ¶
This describes the minimum number of members of the cluster that need to
affirm a proposal so that transactions can be ordered. For every consenter set,
this is a majority of nodes. In a cluster with five nodes, three must be
available for there to be a quorum. If a quorum of nodes is unavailable for any
reason, the cluster becomes unavailable for both read and write operations and
no new logs can be committed.


RaftÂ¶
New for v1.4.1, Raft is a crash fault tolerant (CFT) ordering service
implementation based on the etcd library
of the Raft protocol <https://raft.github.io/raft.pdf>`_. Raft follows a
âleader and followerâ model, where a leader node is elected (per channel) and
its decisions are replicated by the followers. Raft ordering services should
be easier to set up and manage than Kafka-based ordering services, and their
design allows organizations to contribute nodes to a distributed ordering
service.


Software Development Kit (SDK)Â¶
The Hyperledger Fabric client SDK provides a structured environment of libraries
for developers to write and test chaincode applications. The SDK is fully
configurable and extensible through a standard interface. Components, including
cryptographic algorithms for signatures, logging frameworks and state stores,
are easily swapped in and out of the SDK. The SDK provides APIs for transaction
processing, membership services, node traversal and event handling.
Currently, the two officially supported SDKs are for Node.js and Java, while two
more â Python and Go â are not yet official but can still be downloaded
and tested.


Smart ContractÂ¶
A smart contract is code â invoked by a client application external to the
blockchain network â that manages access and modifications to a set of
key-value pairs in the World State via Transaction. In Hyperledger Fabric,
smart contracts are packaged as chaincode. Chaincode is installed on peers
and then defined and used on one or more channels.


State DatabaseÂ¶
World state data is stored in a state database for efficient reads and queries
from chaincode. Supported databases include levelDB and couchDB.


System ChainÂ¶
Contains a configuration block defining the network at a system level. The
system chain lives within the ordering service, and similar to a channel, has
an initial configuration containing information such as: MSP information, policies,
and configuration details.  Any change to the overall network (e.g. a new org
joining or a new ordering node being added) will result in a new configuration block
being added to the system chain.
The system chain can be thought of as the common binding for a channel or group
of channels.  For instance, a collection of financial institutions may form a
consortium (represented through the system chain), and then proceed to create
channels relative to their aligned and varying business agendas.


TransactionÂ¶


A transaction, âTâ

Transactions are created when a chaincode is invoked from a client application
to read or write data from the ledger. Fabric application clients submit transaction proposals to
endorsing peers for execution and endorsement, gather the signed (endorsed) responses from those
endorsing peers, and then package the results and endorsements into a transaction that is
submitted to the ordering service. The ordering service orders and places transactions
in a block that is broadcast to the peers which validate and commit the transactions to the ledger
and update world state.


World StateÂ¶


The World State, âWâ

Also known as the âcurrent stateâ, the world state is a component of the
HyperLedger Fabric Ledger. The world state represents the latest values
for all keys included in the chain transaction log. Chaincode executes
transaction proposals against world state data because the world state provides
direct access to the latest value of these keys rather than having to calculate
them by traversing the entire transaction log. The world state will change
every time the value of a key changes (for example, when the ownership of a
car â the âkeyâ â is transferred from one owner to another â the
âvalueâ) or when a new key is added (a car is created). As a result, the world
state is critical to a transaction flow, since the current state of a key-value
pair must be known before it can be changed. Peers commit the latest values to
the ledger world state for each valid transaction included in a processed block.








Next 
 Previous




        © Copyright Hyperledger 2020.
    
This work is licensed under a Creative Commons Attribution 4.0 International License



          Revision 77bafd68.
        


  Built with Sphinx using a theme provided by Read the Docs. 



https://hyperledger-fabric.readthedocs.io/en/release-2.0/releases.html



Docs »
Releases

 Edit on GitHub







ReleasesÂ¶
Hyperledger Fabric releases are documented on the Fabric github page.







Next 
 Previous




        © Copyright Hyperledger 2020.
    
This work is licensed under a Creative Commons Attribution 4.0 International License



          Revision 77bafd68.
        


  Built with Sphinx using a theme provided by Read the Docs. 



https://hyperledger-fabric.readthedocs.io/en/release-2.0/questions.html



Docs »
Still Have Questions?

 Edit on GitHub







Still Have Questions?Â¶
We try to maintain a comprehensive set of documentation for various
audiences. However, we realize that often there are questions that
remain unanswered. For any technical questions relating to Hyperledger
Fabric not answered here, please use
StackOverflow.
Another approach to getting your questions answered to send an email to
the mailing
list
(fabric@lists.hyperledger.org), or ask your questions on
RocketChat (an alternative to Slack)
on the #fabric or #fabric-questions channel.

Note
Please, when asking about problems you are facing tell us
about the environment in which you are experiencing those
problems including the OS, which version of Docker you are
using, etc.








Next 
 Previous




        © Copyright Hyperledger 2020.
    
This work is licensed under a Creative Commons Attribution 4.0 International License



          Revision 77bafd68.
        


  Built with Sphinx using a theme provided by Read the Docs. 



https://hyperledger-fabric.readthedocs.io/en/release-2.0/status.html



Docs »
Status

 Edit on GitHub







StatusÂ¶
Hyperledger Fabric is in the Active state. For more information on the history of this project see our wiki page. Information on what Active entails can be found in
the Hyperledger Project Lifecycle document.







 Previous




        © Copyright Hyperledger 2020.
    
This work is licensed under a Creative Commons Attribution 4.0 International License



          Revision 77bafd68.
        


  Built with Sphinx using a theme provided by Read the Docs. 



https://hyperledger-fabric.readthedocs.io/en/release-2.0/whatis.html



Docs »
Introduction

 Edit on GitHub







IntroductionÂ¶
In general terms, a blockchain is an immutable transaction ledger, maintained
within a distributed network of peer nodes. These nodes each maintain a copy
of the ledger by applying transactions that have been validated by a consensus
protocol, grouped into blocks that include a hash that bind each block to the
preceding block.
The first and most widely recognized application of blockchain is the
Bitcoin cryptocurrency, though others
have followed in its footsteps. Ethereum, an alternative cryptocurrency, took a
different approach, integrating many of the same characteristics as Bitcoin but
adding smart contracts to create a platform for distributed applications.
Bitcoin and Ethereum fall into a class of blockchain that we would classify as
public permissionless blockchain technology. Basically, these are public
networks, open to anyone, where participants interact anonymously.
As the popularity of Bitcoin, Ethereum and a few other derivative technologies
grew, interest in applying the underlying technology of the blockchain,
distributed ledger and distributed application platform to more innovative
enterprise use cases also grew. However, many enterprise use cases require
performance characteristics that the permissionless blockchain technologies are
unable (presently) to deliver. In addition, in many use cases, the identity of
the participants is a hard requirement, such as in the case of financial
transactions where Know-Your-Customer (KYC) and Anti-Money Laundering (AML)
regulations must be followed.
For enterprise use, we need to consider the following requirements:

Participants must be identified/identifiable
Networks need to be permissioned
High transaction throughput performance
Low latency of transaction confirmation
Privacy and confidentiality of transactions and data pertaining to business
transactions

While many early blockchain platforms are currently being adapted for
enterprise use, Hyperledger Fabric has been designed for enterprise use from
the outset. The following sections describe how Hyperledger Fabric (Fabric)
differentiates itself from other blockchain platforms and describes some of the
motivation for its architectural decisions.

Hyperledger FabricÂ¶
Hyperledger Fabric is an open source enterprise-grade permissioned distributed
ledger technology (DLT) platform, designed for use in enterprise contexts,
that delivers some key differentiating capabilities over other popular
distributed ledger or blockchain platforms.
One key point of differentiation is that Hyperledger was established under the
Linux Foundation, which itself has a long and very successful history of
nurturing open source projects under open governance that grow strong
sustaining communities and thriving ecosystems. Hyperledger is governed by a
diverse technical steering committee, and the Hyperledger Fabric project by a
diverse set of maintainers from multiple organizations. It has a development
community that has grown to over 35 organizations and nearly 200 developers
since its earliest commits.
Fabric has a highly modular and configurable architecture, enabling
innovation, versatility and optimization for a broad range of industry use cases
including banking, finance, insurance, healthcare, human resources, supply
chain and even digital music delivery.
Fabric is the first distributed ledger platform to support smart contracts
authored in general-purpose programming languages such as Java, Go and
Node.js, rather than constrained domain-specific languages (DSL). This means
that most enterprises already have the skill set needed to develop smart
contracts, and no additional training to learn a new language or DSL is needed.
The Fabric platform is also permissioned, meaning that, unlike with a public
permissionless network, the participants are known to each other, rather than
anonymous and therefore fully untrusted. This means that while the participants
may not fully trust one another (they may, for example, be competitors in the
same industry), a network can be operated under a governance model that is built
off of what trust does exist between participants, such as a legal agreement
or framework for handling disputes.
One of the most important of the platformâs differentiators is its support for
pluggable consensus protocols that enable the platform to be more
effectively customized to fit particular use cases and trust models. For
instance, when deployed within a single enterprise, or operated by a trusted
authority, fully byzantine fault tolerant consensus might be considered
unnecessary and an excessive drag on performance and throughput. In situations
such as that, a
crash fault-tolerant (CFT)
consensus protocol might be more than adequate whereas, in a multi-party,
decentralized use case, a more traditional
byzantine fault tolerant
(BFT) consensus protocol might be required.
Fabric can leverage consensus protocols that do not require a native
cryptocurrency to incent costly mining or to fuel smart contract execution.
Avoidance of a cryptocurrency reduces some significant risk/attack vectors,
and absence of cryptographic mining operations means that the platform can be
deployed with roughly the same operational cost as any other distributed system.
The combination of these differentiating design features makes Fabric one of
the better performing platforms available today both in terms of transaction
processing and transaction confirmation latency, and it enables privacy and confidentiality of transactions and the smart contracts (what Fabric calls
âchaincodeâ) that implement them.
Letâs explore these differentiating features in more detail.


ModularityÂ¶
Hyperledger Fabric has been specifically architected to have a modular
architecture. Whether it is pluggable consensus, pluggable identity management
protocols such as LDAP or OpenID Connect, key management protocols or
cryptographic libraries, the platform has been designed at its core to be
configured to meet the diversity of enterprise use case requirements.
At a high level, Fabric is comprised of the following modular components:

A pluggable ordering service establishes consensus on the order of
transactions and then broadcasts blocks to peers.
A pluggable membership service provider is responsible for associating
entities in the network with cryptographic identities.
An optional peer-to-peer gossip service disseminates the blocks output by
ordering service to other peers.
Smart contracts (âchaincodeâ) run within a container environment (e.g. Docker)
for isolation. They can be written in standard programming languages but do not
have direct access to the ledger state.
The ledger can be configured to support a variety of DBMSs.
A pluggable endorsement and validation policy enforcement that can be
independently configured per application.

There is fair agreement in the industry that there is no âone blockchain to
rule them allâ. Hyperledger Fabric can be configured in multiple ways to
satisfy the diverse solution requirements for multiple industry use cases.


Permissioned vs Permissionless BlockchainsÂ¶
In a permissionless blockchain, virtually anyone can participate, and every
participant is anonymous. In such a context, there can be no trust other than
that the state of the blockchain, prior to a certain depth, is immutable. In
order to mitigate this absence of trust, permissionless blockchains typically
employ a âminedâ native cryptocurrency or transaction fees to provide economic
incentive to offset the extraordinary costs of participating in a form of
byzantine fault tolerant consensus based on âproof of workâ (PoW).
Permissioned blockchains, on the other hand, operate a blockchain amongst
a set of known, identified and often vetted participants operating under a
governance model that yields a certain degree of trust. A permissioned
blockchain provides a way to secure the interactions among a group of entities
that have a common goal but which may not fully trust each other. By relying on
the identities of the participants, a permissioned blockchain can use more
traditional crash fault tolerant (CFT) or byzantine fault tolerant (BFT)
consensus protocols that do not require costly mining.
Additionally, in such a permissioned context, the risk of a participant
intentionally introducing malicious code through a smart contract is diminished.
First, the participants are known to one another and all actions, whether
submitting application transactions, modifying the configuration of the network
or deploying a smart contract are recorded on the blockchain following an
endorsement policy that was established for the network and relevant transaction
type. Rather than being completely anonymous, the guilty party can be easily
identified and the incident handled in accordance with the terms of the
governance model.


Smart ContractsÂ¶
A smart contract, or what Fabric calls âchaincodeâ, functions as a trusted
distributed application that gains its security/trust from the blockchain and
the underlying consensus among the peers. It is the business logic of a
blockchain application.
There are three key points that apply to smart contracts, especially when
applied to a platform:

many smart contracts run concurrently in the network,
they may be deployed dynamically (in many cases by anyone), and
application code should be treated as untrusted, potentially even
malicious.

Most existing smart-contract capable blockchain platforms follow an
order-execute architecture in which the consensus protocol:

validates and orders transactions then propagates them to all peer nodes,
each peer then executes the transactions sequentially.

The order-execute architecture can be found in virtually all existing blockchain
systems, ranging from public/permissionless platforms such as
Ethereum (with PoW-based consensus) to permissioned
platforms such as Tendermint,
Chain, and Quorum.
Smart contracts executing in a blockchain that operates with the order-execute
architecture must be deterministic; otherwise, consensus might never be reached.
To address the non-determinism issue, many platforms require that the smart
contracts be written in a non-standard, or domain-specific language
(such as Solidity) so that
non-deterministic operations can be eliminated. This hinders wide-spread
adoption because it requires developers writing smart contracts to learn a new
language and may lead to programming errors.
Further, since all transactions are executed sequentially by all nodes,
performance and scale is limited. The fact that the smart contract code executes
on every node in the system demands that complex measures be taken to protect
the overall system from potentially malicious contracts in order to ensure
resiliency of the overall system.


A New ApproachÂ¶
Fabric introduces a new architecture for transactions that we call
execute-order-validate. It addresses the resiliency, flexibility,
scalability, performance and confidentiality challenges faced by the
order-execute model by separating the transaction flow into three steps:

execute a transaction and check its correctness, thereby endorsing it,
order transactions via a (pluggable) consensus protocol, and
validate transactions against an application-specific endorsement policy
before committing them to the ledger

This design departs radically from the order-execute paradigm in that Fabric
executes transactions before reaching final agreement on their order.
In Fabric, an application-specific endorsement policy specifies which peer
nodes, or how many of them, need to vouch for the correct execution of a given
smart contract. Thus, each transaction need only be executed (endorsed) by the
subset of the peer nodes necessary to satisfy the transactionâs endorsement
policy. This allows for parallel execution increasing overall performance and
scale of the system. This first phase also eliminates any non-determinism,
as inconsistent results can be filtered out before ordering.
Because we have eliminated non-determinism, Fabric is the first blockchain
technology that enables use of standard programming languages.


Privacy and ConfidentialityÂ¶
As we have discussed, in a public, permissionless blockchain network that
leverages PoW for its consensus model, transactions are executed on every node.
This means that neither can there be confidentiality of the contracts
themselves, nor of the transaction data that they process. Every transaction,
and the code that implements it, is visible to every node in the network. In
this case, we have traded confidentiality of contract and data for byzantine
fault tolerant consensus delivered by PoW.
This lack of confidentiality can be problematic for many business/enterprise use
cases. For example, in a network of supply-chain partners, some consumers might
be given preferred rates as a means of either solidifying a relationship, or
promoting additional sales. If every participant can see every contract and
transaction, it becomes impossible to maintain such business relationships in a
completely transparent network â everyone will want the preferred rates!
As a second example, consider the securities industry, where a trader building
a position (or disposing of one) would not want her competitors to know of this,
or else they will seek to get in on the game, weakening the traderâs gambit.
In order to address the lack of privacy and confidentiality for purposes of
delivering on enterprise use case requirements, blockchain platforms have
adopted a variety of approaches. All have their trade-offs.
Encrypting data is one approach to providing confidentiality; however, in a
permissionless network leveraging PoW for its consensus, the encrypted data is
sitting on every node. Given enough time and computational resource, the
encryption could be broken. For many enterprise use cases, the risk that their
information could become compromised is unacceptable.
Zero knowledge proofs (ZKP) are another area of research being explored to
address this problem, the trade-off here being that, presently, computing a ZKP
requires considerable time and computational resources. Hence, the trade-off in
this case is performance for confidentiality.
In a permissioned context that can leverage alternate forms of consensus, one
might explore approaches that restrict the distribution of confidential
information exclusively to authorized nodes.
Hyperledger Fabric, being a permissioned platform, enables confidentiality
through its channel architecture and private data
feature. In channels, participants on a Fabric network establish a sub-network
where every member has visibility to a particular set of transactions. Thus, only
those nodes that participate in a channel have access to the smart contract
(chaincode) and data transacted, preserving the privacy and confidentiality of
both. Private data allows collections between members on a channel, allowing
much of the same protection as channels without the maintenance overhead of
creating and maintaining a separate channel.


Pluggable ConsensusÂ¶
The ordering of transactions is delegated to a modular component for consensus
that is logically decoupled from the peers that execute transactions and
maintain the ledger. Specifically, the ordering service. Since consensus is
modular, its implementation can be tailored to the trust assumption of a
particular deployment or solution. This modular architecture allows the platform
to rely on well-established toolkits for CFT (crash fault-tolerant) or BFT
(byzantine fault-tolerant) ordering.
Fabric currently offers a CFT ordering service implementation
based on the etcd library of the Raft protocol.
For information about currently available ordering services, check
out our conceptual documentation about ordering.
Note also that these are not mutually exclusive. A Fabric network can have
multiple ordering services supporting different applications or application
requirements.


Performance and ScalabilityÂ¶
Performance of a blockchain platform can be affected by many variables such as
transaction size, block size, network size, as well as limits of the hardware,
etc. The Hyperledger Fabric Performance and Scale working group
currently works on a benchmarking framework called Hyperledger Caliper.
Several research papers have been published studying and testing the performance
capabilities of Hyperledger Fabric. The latest scaled Fabric to 20,000 transactions per second.


ConclusionÂ¶
Any serious evaluation of blockchain platforms should include Hyperledger Fabric
in its short list.
Combined, the differentiating capabilities of Fabric make it a highly scalable
system for permissioned blockchains supporting flexible trust assumptions that
enable the platform to support a wide range of industry use cases ranging from
government, to finance, to supply-chain logistics, to healthcare and so much
more.
Hyperledger Fabric is the most active of the Hyperledger projects. The community
building around the platform is growing steadily, and the innovation delivered
with each successive release far out-paces any of the other enterprise blockchain
platforms.


AcknowledgementÂ¶
The preceding is derived from the peer reviewed
âHyperledger Fabric: A Distributed Operating System for Permissioned Blockchainsâ - Elli Androulaki, Artem
Barger, Vita Bortnikov, Christian Cachin, Konstantinos Christidis, Angelo De
Caro, David Enyeart, Christopher Ferris, Gennady Laventman, Yacov Manevich,
Srinivasan Muralidharan, Chet Murthy, Binh Nguyen, Manish Sethi, Gari Singh,
Keith Smith, Alessandro Sorniotti, Chrysoula Stathakopoulou, Marko Vukolic,
Sharon Weed Cocco, Jason Yellick








Next 
 Previous




        © Copyright Hyperledger 2020.
    
This work is licensed under a Creative Commons Attribution 4.0 International License



          Revision 77bafd68.
        


  Built with Sphinx using a theme provided by Read the Docs. 



https://hyperledger-fabric.readthedocs.io/en/release-2.0/whatsnew.html



Docs »
Whatâs new in Hyperledger Fabric v2.0

 Edit on GitHub







Whatâs new in Hyperledger Fabric v2.0Â¶
The first Hyperledger Fabric major release since v1.0, Fabric v2.0
delivers important new features and changes for users and operators alike,
including support for new application and privacy patterns, enhanced
governance around smart contracts, and new options for operating nodes.
What has stayed the same is the ability to upgrade network components on
your own terms, with support for rolling upgrades from v1.4.x, and the ability
to enable the new capabilities only when member organizations are ready.
Letâs take a look at some of the highlights of the Fabric v2.0 releaseâ¦

Decentralized governance for smart contractsÂ¶
Fabric v2.0 introduces decentralized governance for smart contracts, with a new
process for installing a chaincode on your peers and starting it on a channel.
The new Fabric chaincode lifecycle allows multiple organizations to come to
agreement on the parameters of a chaincode, such as the chaincode endorsement
policy, before it can be used to interact with the ledger. The new model
offers several improvements over the previous lifecycle:

Multiple organizations must agree to the parameters of a chaincode
In the release 1.x versions of Fabric, one organization had the ability to
set parameters of a chaincode (for instance the endorsement policy) for all
other channel members, who only had the power to refuse to install the chaincode
and therefore not take part in transactions invoking it. The new Fabric
chaincode lifecycle is more flexible since it supports both centralized
trust models (such as that of the previous lifecycle model) as well as
decentralized models requiring a sufficient number of organizations to
agree on an endorsement policy and other details before the chaincode
becomes active on a channel.
More deliberate chaincode upgrade process In the previous chaincode
lifecycle, the upgrade transaction could be issued by a single organization,
creating a risk for a channel member that had not yet installed the new
chaincode. The new model allows for a chaincode to be upgraded only after
a sufficient number of organizations have approved the upgrade.
Simpler endorsement policy and private data collection updates
Fabric lifecycle allows you to change an endorsement policy or private
data collection configuration without having to repackage or reinstall
the chaincode. Users can also take advantage of a new default endorsement
policy that requires endorsement from a majority of organizations on the
channel. This policy is updated automatically when organizations are
added or removed from the channel.
Inspectable chaincode packages The Fabric lifecycle packages chaincode
in easily readable tar files. This makes it easier to inspect the chaincode
package and coordinate installation across multiple organizations.
Start multiple chaincodes on a channel using one package The previous
lifecycle defined each chaincode on the channel using a name and version
that was specified when the chaincode package was installed. You can now
use a single chaincode package and deploy it multiple times with different
names on the same channel or on different channels. For example, if youâd
like to track different types of assets in their own âcopyâ of the chaincode.
Chaincode packages do not need to be identical across channel members
Organizations can extend a chaincode for their own use case, for example
to perform different validations in the interest of their organization.
As long as the required number of organizations endorse chaincode transactions
with matching results, the transaction will be validated and committed to the
ledger.  This also allows organizations to individually roll out minor fixes
on their own schedules without requiring the entire network to proceed in lock-step.


Using the new chaincode lifecycleÂ¶
For existing Fabric deployments, you can continue to use the prior chaincode
lifecycle with Fabric v2.0. The new chaincode lifecycle will become effective
only when the channel application capability is updated to v2.0.
See the Fabric chaincode lifecycle concept topic for an overview of the new
chaincode lifecycle.



New chaincode application patterns for collaboration and consensusÂ¶
The same decentralized methods of coming to agreement that underpin the
new chaincode lifecycle management can also be used in your own chaincode
applications to ensure organizations consent to data transactions before
they are committed to the ledger.

Automated checks As mentioned above, organizations can add automated
checks to chaincode functions to validate additional information before
endorsing a transaction proposal.
Decentralized agreement Human decisions can be modeled into a chaincode process
that spans multiple transactions. The chaincode may require actors from
various organizations to indicate their terms and conditions of agreement
in a ledger transaction. Then, a final chaincode proposal can
verify that the conditions from all the individual transactors are met,
and âsettleâ the business transaction with finality across all channel
members. For a concrete example of indicating terms and conditions in private,
see the asset transfer scenario in the Private data documentation.



Private data enhancementsÂ¶
Fabric v2.0 also enables new patterns for working with and sharing private data,
without the requirement of creating private data collections for all
combinations of channel members that may want to transact. Specifically,
instead of sharing private data within a collection of multiple members,
you may want to share private data across collections, where each collection
may include a single organization, or perhaps a single organization along
with a regulator or auditor.
Several enhancements in Fabric v2.0 make these new private data patterns possible:

Sharing and verifying private data When private data is shared with a
channel member who is not a member of a collection, or shared with another
private data collection that contains one or more channel members (by writing
a key to that collection), the receiving parties can utilize the
GetPrivateDataHash() chaincode API to verify that the private data matches the
on-chain hashes that were created from private data in previous transactions.
Collection-level endorsement policies Private data collections can now
optionally be defined with an endorsement policy that overrides the
chaincode-level endorsement policy for keys within the collection. This
feature can be used to restrict which organizations can write data to a
collection, and is what enables the new chaincode lifecycle and chaincode
application patterns mentioned earlier. For example, you may have a chaincode
endorsement policy that requires a majority of organizations to endorse,
but for any given transaction, you may need two transacting organizations
to individually endorse their agreement in their own private data collections.
Implicit per-organization collections If youâd like to utilize
per-organization private data patterns, you donât even need to define the
collections when deploying chaincode in Fabric v2.0.  Implicit
organization-specific collections can be used without any upfront definition.

To learn more about the new private data patterns, see the Private data (conceptual
documentation). For details about private data collection configuration and
implicit collections, see the Private Data (reference documentation).


External chaincode launcherÂ¶
The external chaincode launcher feature empowers operators to build and launch
chaincode with the technology of their choice. Use of external builders and launchers
is not required as the default behavior builds and runs chaincode in the same manner
as prior releases using the Docker API.

Eliminate Docker daemon dependency Prior releases of Fabric required
peers to have access to a Docker daemon in order to build and launch
chaincode - something that may not be desirable in production environments
due to the privileges required by the peer process.
Alternatives to containers Chaincode is no longer required to be run
in Docker containers, and may be executed in the operatorâs choice of
environment (including containers).
External builder executables An operator can provide a set of external
builder executables to override how the peer builds and launches chaincode.
Chaincode as an external service Traditionally, chaincodes are launched
by the peer, and then connect back to the peer. It is now possible to run chaincode as
an external service, for example in a Kubernetes pod, which a peer can
connect to and utilize for chaincode execution. See Chaincode as an external service for more
information.

See External Builders and Launchers to learn more about the external chaincode launcher feature.


State database cache for improved performance on CouchDBÂ¶

When using external CouchDB state database, read delays during endorsement
and validation phases have historically been a performance bottleneck.
With Fabric v2.0, a new peer cache replaces many of these expensive lookups
with fast local cache reads. The cache size can be configured by using the
core.yaml property cacheSize.



Alpine-based docker imagesÂ¶
Starting with v2.0, Hyperledger Fabric Docker images will use Alpine Linux,
a security-oriented, lightweight Linux distribution. This means that Docker
images are now much smaller, providing faster download and startup times,
as well as taking up less disk space on host systems. Alpine Linux is designed
from the ground up with security in mind, and the minimalist nature of the Alpine
distribution greatly reduces the risk of security vulnerabilities.


Sample test networkÂ¶
The fabric-samples repository now includes a new Fabric test network. The test
network is built to be a modular and user friendly sample Fabric network that
makes it easy to test your applications and smart contracts. The network also
supports the ability to deploy your network using Certificate Authorities,
in addition to cryptogen.
For more information about this network, check out Using the Fabric test network.


Upgrading to Fabric v2.0Â¶
A major new release brings some additional upgrade considerations. Rest assured
though, that rolling upgrades from v1.4.x to v2.0 are supported, so that network
components can be upgraded one at a time with no downtime.
The upgrade docs have been significantly expanded and reworked, and now have a
standalone home in the documentation: Upgrading to the latest release. Here youâll find documentation on
Upgrading your components and Updating the capability level of a channel, as well as a
specific look  at the considerations for upgrading to v2.0, Considerations for getting to v2.0.



Release notesÂ¶
The release notes provide more details for users moving to the new release.
Specifically, take a look at the changes and deprecations that are being
announced with the new Fabric v2.0 release.

Fabric v2.0.0 release notes.
Fabric v2.0.1 release notes.








Next 
 Previous




        © Copyright Hyperledger 2020.
    
This work is licensed under a Creative Commons Attribution 4.0 International License



          Revision 77bafd68.
        


  Built with Sphinx using a theme provided by Read the Docs. 



https://hyperledger-fabric.readthedocs.io/en/release-2.0/whatsnew.html#release-notes



Docs »
Whatâs new in Hyperledger Fabric v2.0

 Edit on GitHub







Whatâs new in Hyperledger Fabric v2.0Â¶
The first Hyperledger Fabric major release since v1.0, Fabric v2.0
delivers important new features and changes for users and operators alike,
including support for new application and privacy patterns, enhanced
governance around smart contracts, and new options for operating nodes.
What has stayed the same is the ability to upgrade network components on
your own terms, with support for rolling upgrades from v1.4.x, and the ability
to enable the new capabilities only when member organizations are ready.
Letâs take a look at some of the highlights of the Fabric v2.0 releaseâ¦

Decentralized governance for smart contractsÂ¶
Fabric v2.0 introduces decentralized governance for smart contracts, with a new
process for installing a chaincode on your peers and starting it on a channel.
The new Fabric chaincode lifecycle allows multiple organizations to come to
agreement on the parameters of a chaincode, such as the chaincode endorsement
policy, before it can be used to interact with the ledger. The new model
offers several improvements over the previous lifecycle:

Multiple organizations must agree to the parameters of a chaincode
In the release 1.x versions of Fabric, one organization had the ability to
set parameters of a chaincode (for instance the endorsement policy) for all
other channel members, who only had the power to refuse to install the chaincode
and therefore not take part in transactions invoking it. The new Fabric
chaincode lifecycle is more flexible since it supports both centralized
trust models (such as that of the previous lifecycle model) as well as
decentralized models requiring a sufficient number of organizations to
agree on an endorsement policy and other details before the chaincode
becomes active on a channel.
More deliberate chaincode upgrade process In the previous chaincode
lifecycle, the upgrade transaction could be issued by a single organization,
creating a risk for a channel member that had not yet installed the new
chaincode. The new model allows for a chaincode to be upgraded only after
a sufficient number of organizations have approved the upgrade.
Simpler endorsement policy and private data collection updates
Fabric lifecycle allows you to change an endorsement policy or private
data collection configuration without having to repackage or reinstall
the chaincode. Users can also take advantage of a new default endorsement
policy that requires endorsement from a majority of organizations on the
channel. This policy is updated automatically when organizations are
added or removed from the channel.
Inspectable chaincode packages The Fabric lifecycle packages chaincode
in easily readable tar files. This makes it easier to inspect the chaincode
package and coordinate installation across multiple organizations.
Start multiple chaincodes on a channel using one package The previous
lifecycle defined each chaincode on the channel using a name and version
that was specified when the chaincode package was installed. You can now
use a single chaincode package and deploy it multiple times with different
names on the same channel or on different channels. For example, if youâd
like to track different types of assets in their own âcopyâ of the chaincode.
Chaincode packages do not need to be identical across channel members
Organizations can extend a chaincode for their own use case, for example
to perform different validations in the interest of their organization.
As long as the required number of organizations endorse chaincode transactions
with matching results, the transaction will be validated and committed to the
ledger.  This also allows organizations to individually roll out minor fixes
on their own schedules without requiring the entire network to proceed in lock-step.


Using the new chaincode lifecycleÂ¶
For existing Fabric deployments, you can continue to use the prior chaincode
lifecycle with Fabric v2.0. The new chaincode lifecycle will become effective
only when the channel application capability is updated to v2.0.
See the Fabric chaincode lifecycle concept topic for an overview of the new
chaincode lifecycle.



New chaincode application patterns for collaboration and consensusÂ¶
The same decentralized methods of coming to agreement that underpin the
new chaincode lifecycle management can also be used in your own chaincode
applications to ensure organizations consent to data transactions before
they are committed to the ledger.

Automated checks As mentioned above, organizations can add automated
checks to chaincode functions to validate additional information before
endorsing a transaction proposal.
Decentralized agreement Human decisions can be modeled into a chaincode process
that spans multiple transactions. The chaincode may require actors from
various organizations to indicate their terms and conditions of agreement
in a ledger transaction. Then, a final chaincode proposal can
verify that the conditions from all the individual transactors are met,
and âsettleâ the business transaction with finality across all channel
members. For a concrete example of indicating terms and conditions in private,
see the asset transfer scenario in the Private data documentation.



Private data enhancementsÂ¶
Fabric v2.0 also enables new patterns for working with and sharing private data,
without the requirement of creating private data collections for all
combinations of channel members that may want to transact. Specifically,
instead of sharing private data within a collection of multiple members,
you may want to share private data across collections, where each collection
may include a single organization, or perhaps a single organization along
with a regulator or auditor.
Several enhancements in Fabric v2.0 make these new private data patterns possible:

Sharing and verifying private data When private data is shared with a
channel member who is not a member of a collection, or shared with another
private data collection that contains one or more channel members (by writing
a key to that collection), the receiving parties can utilize the
GetPrivateDataHash() chaincode API to verify that the private data matches the
on-chain hashes that were created from private data in previous transactions.
Collection-level endorsement policies Private data collections can now
optionally be defined with an endorsement policy that overrides the
chaincode-level endorsement policy for keys within the collection. This
feature can be used to restrict which organizations can write data to a
collection, and is what enables the new chaincode lifecycle and chaincode
application patterns mentioned earlier. For example, you may have a chaincode
endorsement policy that requires a majority of organizations to endorse,
but for any given transaction, you may need two transacting organizations
to individually endorse their agreement in their own private data collections.
Implicit per-organization collections If youâd like to utilize
per-organization private data patterns, you donât even need to define the
collections when deploying chaincode in Fabric v2.0.  Implicit
organization-specific collections can be used without any upfront definition.

To learn more about the new private data patterns, see the Private data (conceptual
documentation). For details about private data collection configuration and
implicit collections, see the Private Data (reference documentation).


External chaincode launcherÂ¶
The external chaincode launcher feature empowers operators to build and launch
chaincode with the technology of their choice. Use of external builders and launchers
is not required as the default behavior builds and runs chaincode in the same manner
as prior releases using the Docker API.

Eliminate Docker daemon dependency Prior releases of Fabric required
peers to have access to a Docker daemon in order to build and launch
chaincode - something that may not be desirable in production environments
due to the privileges required by the peer process.
Alternatives to containers Chaincode is no longer required to be run
in Docker containers, and may be executed in the operatorâs choice of
environment (including containers).
External builder executables An operator can provide a set of external
builder executables to override how the peer builds and launches chaincode.
Chaincode as an external service Traditionally, chaincodes are launched
by the peer, and then connect back to the peer. It is now possible to run chaincode as
an external service, for example in a Kubernetes pod, which a peer can
connect to and utilize for chaincode execution. See Chaincode as an external service for more
information.

See External Builders and Launchers to learn more about the external chaincode launcher feature.


State database cache for improved performance on CouchDBÂ¶

When using external CouchDB state database, read delays during endorsement
and validation phases have historically been a performance bottleneck.
With Fabric v2.0, a new peer cache replaces many of these expensive lookups
with fast local cache reads. The cache size can be configured by using the
core.yaml property cacheSize.



Alpine-based docker imagesÂ¶
Starting with v2.0, Hyperledger Fabric Docker images will use Alpine Linux,
a security-oriented, lightweight Linux distribution. This means that Docker
images are now much smaller, providing faster download and startup times,
as well as taking up less disk space on host systems. Alpine Linux is designed
from the ground up with security in mind, and the minimalist nature of the Alpine
distribution greatly reduces the risk of security vulnerabilities.


Sample test networkÂ¶
The fabric-samples repository now includes a new Fabric test network. The test
network is built to be a modular and user friendly sample Fabric network that
makes it easy to test your applications and smart contracts. The network also
supports the ability to deploy your network using Certificate Authorities,
in addition to cryptogen.
For more information about this network, check out Using the Fabric test network.


Upgrading to Fabric v2.0Â¶
A major new release brings some additional upgrade considerations. Rest assured
though, that rolling upgrades from v1.4.x to v2.0 are supported, so that network
components can be upgraded one at a time with no downtime.
The upgrade docs have been significantly expanded and reworked, and now have a
standalone home in the documentation: Upgrading to the latest release. Here youâll find documentation on
Upgrading your components and Updating the capability level of a channel, as well as a
specific look  at the considerations for upgrading to v2.0, Considerations for getting to v2.0.



Release notesÂ¶
The release notes provide more details for users moving to the new release.
Specifically, take a look at the changes and deprecations that are being
announced with the new Fabric v2.0 release.

Fabric v2.0.0 release notes.
Fabric v2.0.1 release notes.








Next 
 Previous




        © Copyright Hyperledger 2020.
    
This work is licensed under a Creative Commons Attribution 4.0 International License



          Revision 77bafd68.
        


  Built with Sphinx using a theme provided by Read the Docs. 



https://hyperledger-fabric.readthedocs.io/en/release-2.0/key_concepts.html



Docs »
Key Concepts

 Edit on GitHub







Key ConceptsÂ¶


Introduction
Hyperledger Fabric Model
Blockchain network
Identity
Membership Service Provider (MSP)
Policies
Peers
Ledger
The Ordering Service
Smart Contracts and Chaincode
Fabric chaincode lifecycle
Private data
Channel capabilities
Use Cases









Next 
 Previous




        © Copyright Hyperledger 2020.
    
This work is licensed under a Creative Commons Attribution 4.0 International License



          Revision 77bafd68.
        


  Built with Sphinx using a theme provided by Read the Docs. 



https://hyperledger-fabric.readthedocs.io/en/release-2.0/getting_started.html



Docs »
Getting Started

 Edit on GitHub







Getting StartedÂ¶


Before we begin, if you havenât already done so, you may wish to check that
you have all the Prerequisites installed on the platform(s)
on which youâll be developing blockchain applications and/or operating
Hyperledger Fabric.
Once you have the prerequisites installed, you are ready to download and
install HyperLedger Fabric. While we work on developing real installers for the
Fabric binaries, we provide a script that will Install Samples, Binaries and Docker Images to your system.
The script also will download the Docker images to your local registry.
After you have downloaded the Fabric Samples and Docker images to your local
machine, you can get started working with Fabric with the
Using the Fabric test network tutorial.

Hyperledger Fabric smart contract (chaincode) APIsÂ¶
Hyperledger Fabric offers a number of APIs to support developing smart contracts (chaincode)
in various programming languages. Smart contract APIs are available for Go, Node.js, and Java:


Go contract-api.
Node.js contract API and Node.js contract API documentation.
Java contract API and Java contract API documentation.




Hyperledger Fabric application SDKsÂ¶
Hyperledger Fabric offers a number of SDKs to support developing applications
in various programming languages. SDKs are available for Node.js and Java:


Node.js SDK and Node.js SDK documentation.
Java SDK and Java SDK documentation.


In addition, there are two more application SDKs that have not yet been officially released
(for Python and Go), but they are still available for downloading and testing:


Python SDK.
Go SDK.


Currently, Node.js and Java support the new application programming model delivered in
Hyperledger Fabric v1.4. Support for Go is planned to be delivered in a later release.


Hyperledger Fabric CAÂ¶
Hyperledger Fabric provides an optional
certificate authority service
that you may choose to use to generate the certificates and key material
to configure and manage identity in your blockchain network. However, any CA
that can generate ECDSA certificates may be used.








Next 
 Previous




        © Copyright Hyperledger 2020.
    
This work is licensed under a Creative Commons Attribution 4.0 International License



          Revision 77bafd68.
        


  Built with Sphinx using a theme provided by Read the Docs. 



https://hyperledger-fabric.readthedocs.io/en/release-2.0/developapps/developing_applications.html



Docs »
Developing Applications

 Edit on GitHub







Developing ApplicationsÂ¶


This topic covers how to develop a client application and smart contract to
solve a business problem using Hyperledger Fabric. In a real world Commercial
Paper scenario, involving multiple organizations, youâll learn about all the
concepts and tasks required to accomplish this goal. We assume that the
blockchain network is already available.
The topic is designed for multiple audiences:

Solution and application architect
Client application developer
Smart contract developer
Business professional

You can choose to read the topic in order, or you can select individual sections
as appropriate. Individual topic sections are marked according to reader
relevance, so whether youâre looking for business or technical information itâll
be clear when a topic is for you.
The topic follows a typical software development lifecycle. It starts with
business requirements, and then covers all the major technical activities
required to develop an application and smart contract to meet these
requirements.
If youâd prefer, you can try out the commercial paper scenario immediately,
following an abbreviated explanation, by running the commercial paper tutorial. You can return to this topic when you
need fuller explanations of the concepts introduced in the tutorial.







Next 
 Previous




        © Copyright Hyperledger 2020.
    
This work is licensed under a Creative Commons Attribution 4.0 International License



          Revision 77bafd68.
        


  Built with Sphinx using a theme provided by Read the Docs. 



https://hyperledger-fabric.readthedocs.io/en/release-2.0/tutorials.html



Docs »
Tutorials

 Edit on GitHub







TutorialsÂ¶
Application developers can use the Fabric tutorials to get started building their
own solutions. Start working with Fabric by deploying the test network
on your local machine. You can then use the steps provided by the Deploying a smart contract to a channel
tutorial to deploy and test your smart contracts. The Writing Your First Application
tutorial provides an introduction to how to use the APIs provided by the Fabric
SDKs to invoke smart contracts from your client applications. For an in depth
overview of how Fabric applications and smart contracts work together, you
can visit the Developing Applications topic.
The Deploying a smart contract to a channel tutorial can also be used by network operators to learn
how to use the Fabric chaincode lifecycle to manage smart contracts deployed on
a running network. Both network operators and application developers can use the
tutorials on Private data and CouchDB
to explore important Fabric features. When you are ready to deploy Hyperledger
Fabric in production, see the guide for Deploying a production network.
There are two tutorials for updating a channel: Updating a channel configuration and
Updating the capability level of a channel, while Upgrading your components shows how
to upgrade components like peers, ordering nodes, SDKs, and more.
Finally, we provide an introduction to how to write a basic smart contract,
Chaincode for Developers.

Note
If you have questions not addressed by this documentation, or run into
issues with any of the tutorials, please visit the Still Have Questions?
page for some tips on where to find additional help.


Tutorials

Using the Fabric test network
Deploying a smart contract to a channel
Writing Your First Application
Commercial paper tutorial
Using Private Data in Fabric
Using CouchDB
Adding an Org to a Channel
Updating a channel configuration
Chaincode for Developers
Building Your First Network
Videos









Next 
 Previous




        © Copyright Hyperledger 2020.
    
This work is licensed under a Creative Commons Attribution 4.0 International License



          Revision 77bafd68.
        


  Built with Sphinx using a theme provided by Read the Docs. 



https://hyperledger-fabric.readthedocs.io/en/release-2.0/deployment_guide_overview.html



Docs »
Deploying a production network

 Edit on GitHub







Deploying a production networkÂ¶
This deployment guide is a high level overview of the proper sequence for setting up production Fabric network components, in addition to best practices and a few of the many considerations to keep in mind when deploying. Note that this topic will discuss âsetting up the networkâ as a holistic process from the perspective of a single individual. More likely than not, real world production networks will not be set up by a single individual but as a collaborative effort directed by several individuals (a collection of banks each setting up their own components, for example) instead.
The process for deploying a Fabric network is complex and presumes an understanding of Public Key Infrastructure and managing distributed systems. If you are a smart contract or application developer, you should not need this level of expertise in deploying a production level Fabric network. However, you might need to be aware of how networks are deployed in order to develop effective smart contracts and applications.
If all you need is a development environment to test chaincode, smart contracts, and applications against, check out Using the Fabric test network. It includes two organizations, each owning one peer, and a single ordering service organization that owns a single ordering node. This test network is not meant to provide a blueprint for deploying production components, and should not be used as such, as it makes assumptions and decisions that production deployments will not make.
The guide will give you an overview of the steps of setting up production components and a production network:

Step one: Decide on your network configuration

Step two: Set up a cluster for your resources

Step three: Set up your CAs

Step four: Use the CA to create identities and MSPs


Step five: Deploy nodes

Create a peer
Create an ordering node






Step one: Decide on your network configurationÂ¶
The structure of a blockchain network must be dictated by the use case. These fundamental business decisions will vary according to your use case, but letâs consider a few scenarios.
In contrast to development environments or proofs of concept, security, resource management, and high availability become a priority when operating in production. How many nodes do you need to satisfy high availability, and in what data centers do you wish to deploy them in to satisfy both the needs of disaster recovery and data residency? How will you ensure that your private keys and roots of trust remain secure?
In addition to the above, here is a sampling of the decisions you will need to make before deploying components:

Certificate Authority configuration.
As part of the overall decisions you have to make about your peers (how many, how many on each channel, and so on) and about your ordering service (how many nodes, who will own them), you also have to decide on how the CAs for your organization will be deployed. Production networks should be using Transport Layer Security (TLS), which will require setting up a TLS CA and using it to generate TLS certficates. This TLS CA will need to be deployed before your enrollment CA. Weâll discuss this more in Step three: Set up your CAs.
Use Organizational Units or not?
Some organizations might find it necessary to establish Organizational Units to create a separation between certain identities and MSPs created by a single CA.
Database type.
Some channels in a network might require all data to be modeled in a way CouchDB as the State Database can understand, while other networks, prioritizing speed, might decide that all peers will use LevelDB. Note that channels should not have peers that use both CouchDB and LevelDB on them, as the two database types model data slightly differently.
Channels and private data.
Some networks might decide that Channels are the best way to ensure privacy and isolation for certain transactions. Others might decide that a single channel, along with Private data, better serves their need for privacy.
Container orchestration.
Different users might also make different decisions about their container orchestration, creating separate containers for their peer process, logging for the peer, CouchDB, gRPC communications, and chaincode, while other users might decide to combine some of these processes.
Chaincode deployment method.
Users now have the option to deploy their chaincode using either the built in build and run support, a customized build and run using the External Builders and Launchers, or using an Chaincode as an external service.
Using firewalls.
In a production deployment, components belonging to one organization might need access to components from other organizations, necessitating the use of firewalls and advanced networking configuration. For example, applications using the Fabric SDK require access to all endorsing peers from all organizations and the ordering services for all channels. Similarly, peers need access to the ordering service on the channels that they are receiving new blocks from.

However and wherever your components are deployed, you will need a high degree of expertise in your management system of choice (such as Kubernetes) in order to efficiently operate your network. Similarly, the structure of the network must be designed to fit the business use case and any relevant laws and regulations government of the industry in which the network will be designed to function.
This deployment guide will not go through every iteration and potential network configuration, but does give common guidelines and rules to consider.


Step two: Set up a cluster for your resourcesÂ¶
Generally speaking, Fabric is agnostic to the method used to deploy and manage it. It is possible, for example, to deploy and manage a peer from a laptop. For a number of reasons, this is likely to be unadvisable, but there is nothing in Fabric that prohibits it.
As long as you have the ability to deploy containers, whether locally (or behind a firewall), or in a cloud, it should be possible to stand up components and connect them to each other. However, Kubernetes features a number of helpful tools that have made it a popular container management platform for deploying and managing Fabric networks. For more information about Kubernetes, check out the Kubernetes documentation. This topic will mostly limit its scope to the binaries and provide instructions that can be applied when using a Docker deployment or Kubernetes.
However and wherever you choose to deploy your components, you will need to make sure you have enough resources for the components to run effectively. The sizes you need will largely depend on your use case. If you plan to join a single peer to several high volume channels, it will need much more CPU and memory than a peer a user plans to join to a single channel. As a rough estimate, plan to dedicate approximately three times the resources to a peer as you plan to allocate to a single ordering node (as you will see below, it is recommended to deploy at least three and optimally five nodes in an ordering service). Similarly, you should need approximately a tenth of the resources for a CA as you will for a peer. You will also need to add storage to your cluster (some cloud providers may provide storage) as you cannot configure Persistent Volumes and Persistent Volume Claims without storage being set up with your cloud provider first.
By deploying a proof of concept network and testing it under load, you will have a better sense of the resources you will require.

Managing your infrastructureÂ¶
The exact methods and tools you use to manage your backend will depend on the backend you choose. However, here are some considerations worth noting.

Using secret objects to securely store important configuration files in your cluster. For information about Kubernetes secrets, check out Kubernetes secrets. You also have the option to use Hardened Security Modules (HSMs) or encrypted Persistent Volumes (PVs). Along similar lines, after deploying Fabric components, you will likely want to connect to a container on your own backend, for example using a private repo in a service like Docker Hub. In that case, you will need to code the login information in the form of a Kubernetes secret and include it in the YAML file when deploying components.
Cluster considerations and node sizing. In step 2 above, we discussed a general outline for how to think about the sizings of nodes. Your use case, as well as a robust period of development, is the only way you will truly know how how large your peers, ordering nodes, and CAs will need to be.
How you choose to mount your volumes. It is a best practice to mount the volumes relevant to your nodes external to the place where your nodes are deployed. This will allow you to reference these volumes later on (for example, restarting a node or a container that has crashed) without having to redeploy or regenerate your crypto material.
How you will monitor your resources. It is critical that you establish a strategy and method for monitoring the resources used by your individual nodes and the resources deployed to your cluster generally. As you join your peers to more channels, you will need likely need to increase its CPU and memory allocation. Similarly, you will need to make sure you have enough storage space for your state database and blockchain.




Step three: Set up your CAsÂ¶
The first component that must be deployed in a Fabric network is a CA. This is because the certificates associated with a node (not just for the node itself but also the certificates identifying who can administer the node) must be created before the node itself can be deployed. While it is not necessary to use the Fabric CA to create these certificates, the Fabric CA also creates MSP structures that are needed for components and organizations to be properly defined. If a user chooses to use a CA other than the Fabric CA, they will have to create the MSP folders themselves.

One CA (or more, if you are using intermediate CAs â more on intermediate CAs below) is used to generate (through a process called âenrollmentâ) the certificates of the admin of an organization, the MSP of that organization, and any nodes owned by that organization. This CA will also generate the certificates for any additional users. Because of its role in âenrollingâ identities, this CA is sometimes called the âenrollment CAâ or the âecert CAâ.
The other CA generates the certificates used to secure communications on Transport Layer Security (TLS). For this reason, this CA is often referred to as a âTLS CAâ. These TLS certificates are attached to actions as a way of preventing âman in the middleâ attacks. Note that the TLS CA is only used for issuing certificates for nodes and can be shut down when that activity is completed. Users have the option to use one way (client only) TLS as well as two way (server and client) TLS, with the latter also known as âmutual TLSâ. Because specifying that your network will be using TLS (which is recommended) should be decided before deploying the âenrollmentâ CA (the YAML file specifying the configuration of this CA has a field for enabling TLS), you should deploy your TLS CA first and use its root certificate when bootstrapping your enrollment CA. This TLS certificate will also be used by the fabric-ca client when connecting to the enrollment CA to enroll identities for users and nodes.

While all of the non-TLS certificates associated with an organization can be created by a single ârootâ CA (that is, a CA that is its own root of trust), for added security organizations can decide to use âintermediateâ CAs whose certificates are created by a root CA (or another intermediate CA that eventually leads back to a root CA). Because a compromise in the root CA leads to a collapse for its entire trust domain (the certs for the admins, nodes, and any CAs it has generated certificates for), intermediate CAs are a useful way to limit the exposure of the root CA. Whether you choose to use intermediate CAs will depend on the needs of your use case. They are not mandatory. Note that it is also possible to configure a Lightweight Directory Access Protocol (LDAP) to manage identities on a Fabric network for those enterprises that already have this implementation and do not want to add a layer of identity management to their existing infrastructure. The LDAP effectively pre registers all of the members of the directory and allows them to enroll based on the criteria given.
In a production network, it is recommended to deploy at least one CA per organization for enrollment purposes and another for TLS. For example, if you deploy three peers that are associated with one organization and an ordering node that is associated with an ordering organization, you will need at least four CAs. Two of the CAs will be for the peer organization (generating the enrollment and TLS certificates for the peer, admins, communications, and the folder structure of the MSP representing the organization) and the other two will be for the orderer organization. Note that users will generally only register and enroll with the enrollment CA, while nodes will register and enroll with both the enrollment CA (where the node will get its signing certificates that identify it when it attempts to sign its actions) and with the TLS CA (where it will get the TLS certificates it uses to authenticate its communications).
To install the Fabric CA client, which is used to register and enroll identities, follow the instructions in the Fabric CA Userâs Guide. Note that there are a number of configuration options when deploying a CA (the database type, for example, or whether to use LDAP).
For an example of how to setup a CA and enroll its admin, check out Setup Orderer Org CA. For an example of how to set up a TLS CA, check out Setup TLS CA. Note that bootstrapping the CA server means assigning a username and password that functions as âregisteringâ the CA admin.


Step four: Use the CA to create identities and MSPsÂ¶
After you have created your CAs, you can use them to create the certificates for the identities and components related to your organization (which is represented by an MSP). For each organization, you will need to, at a minimum:

Register and enroll an admin identity and create an MSP. After the CA that will be associated with an organization has been created, it can be used to first register an identity and then enroll it. In the first step, a username and password for the identity is assigned by the admin of the CA. Attributes and affiliations can also be given to the identity (for example, a role of admin, which is necessary for organization admins). After the identity has been registered, it can be enrolled by using the username and password. The CA will generate two certificates for this identity â a public certificate (also known as a signcert) known to the other members of the network, and the private key (stored in the keystore folder) used to sign actions taken by the identity. The CA will also generate an MSP file containing the public certificate of the CA issuing the certificate and the root of trust for the CA (this may or may not be the same CA). This MSP can be thought of as defining the organization associated with the identity of the admin. For an example of how this process looks, check out the this example of how an admin is enrolled. In cases where the admin of the org will also be an admin of a node (which will be typical), you must create the org admin identity before creating the local MSP of a node, since the certificate of the node admin must be used when creating the local MSP.
Register and enroll node identities. Just as an org admin identity is registered and enrolled, the identity of a node must be registered and enrolled with both an enrollment CA and the TLS CA. For this reason, it can be useful for your enrollment CA and TLS to share a database (which allows the node identity to only be registered once and enrolled by each CA server separately), though this is an optional configuration option. Instead of giving a node a role of admin or user when registering it with the enrollment CA, give it a role of peer or orderer. As with the admin, attributes and affiliations for this identity can also be assigned. The MSP structure for a node is known as a âlocal MSPâ, since the permissions assigned to the identities are only relevant at the local (node) level. This MSP is created when the node identity is created, and is used when bootstrapping the node. You will use the TLS root certificate generated when enrolling with the TLS CA when joining your organization to the channel (this certificate must be added to the org MSP that was created when you enrolled your admin) and when using the peer binary as a CLI client to make calls to other peers (as in peer chaincode invoke) or ordering nodes (as in peer channel fetch) because there is no orderer CLI. It is not necessary to add the TLS root certificates to the local MSP of a node because these certificates are contained in the channel configuration.

For more conceptual information about identities and permissions in a Fabric-based blockchain network, see Identity and membership/membership.html.
For a look at how to use a CA to generate an admin identity and MSP, check out Enroll Org1âs Admin.
To see how to use the enrollment CA to and the TLS CA to generate the certificates for a node, check out Setup Org1âs Peers.


Step five: Deploy nodesÂ¶
Once you have gathered all of the certificates and MSPs you need, youâre almost ready to create a node. As discussed above, there are a number of valid ways to deploy nodes.

Create a peerÂ¶
Before you can create a peer, you will need to customize the configuration file for the peer. In Fabric, this file is called core.yaml. You can find a sample core.yaml configuration file in the sampleconfig directory of Hyperledger Fabric.
As you can see in the file, there are quite a number of parameters you either have the option to set or will need to set for your node to work properly. In general, if you do not have the need to change a tuning value, leave it alone. You will, however, likely need to adjust the various addresses, specify the database type you want to use, as well as to specify where the MSP for the node is located.
You have two main options for tuning your configuration.

Edit the YAML file bundled with the binaries.
Use environment variable overrides when deploying.
Specify flags on CLI commands.

Option 1 has the advantage of persisting your changes whenever you bring down and bring back up the node. The downside is that you will have to port the options you customized to the new YAML when upgrading to a new binary version (you should use the latest YAML when upgrading to a new version).
Either way, here are some values in core.yaml you must review.

peer.localMspID: this is the name of the local MSP of your peer organization. This MSP is where your peer organization admins will be listed as well as the peer organizationâs root CA and TLS CA certificates.
peer.mspConfigPath: the place where the local MSP for the peer is located. Note that it is a best practice to mount this volume external to your container. This ensures that even if the container is stopped (for example, during a maintenance cycle) that the MSPs are not lost and have to be recreated.
peer.address: represents the endpoint to other peers in the same organization, an important consideration when establishing gossip communication within an organization.
peer.tls: When you set the enabled value to true (as should be done in a production network), you will have to specify the locations of the relevant TLS certificates. Note that all of the nodes in a network (both the peers and the ordering nodes) must either all have TLS enabled or not enabled. For production networks, it is highly recommended to enable TLS. As with your MSP, it is a best practice to mount this volume external to your container.
ledger: users have a number of decisions to make about their ledger, including the state database type (LevelDB or CouchDB, for example), and its location (specified in fileSystemPath). Note that for CouchDB in particular it is a best practice to operate your state database external to the peer, as you will be better able to allocate specific resources to the database this way.
gossip: there are a number of configuration options to think about when setting up Gossip data dissemination protocol, including the externalEndpoint (which makes peers discoverable to peers owned by other organizations) as well as the bootstrap address (which identifies a peer in the peerâs own organization).
chaincode.externalBuilders: this field is important to set when using cc_service.html.

When youâre comfortable with how your peer has been configured, how your volumes are mounted, and your backend configuration, you can run the command to launch the peer (this command will depend on your backend configuration).


Create an ordering nodeÂ¶
Unlike the creation of a peer, you will need to create a genesis block (or reference a block that has already been created, if adding an ordering node to an existing ordering service) and specify the path to it before launching the ordering node.
In Fabric, this configuration file for ordering nodes is called orderer.yaml. You can find a sample orderer.yaml configuration file in the sampleconfig directory of Hyperledger Fabric. Note that orderer.yaml is different than the âgenesis blockâ of an ordering service. This block, which includes the initial configuration of the orderer system channel, must be created before an ordering node is created because it is used to bootstrap the node.
As with the peer, you will see that there are quite a number of parameters you either have the option to set or will need to set for your node to work properly. In general, if you do not have the need to change a tuning value, leave it alone.
You have two main options for tuning your configuration.

Edit the YAML file bundled with the binaries.
Use environment variable overrides when deploying.
Specify flags on CLI commands.

Option 1 has the advantage of persisting your changes whenever you bring down and bring back up the node. The downside is that you will have to port the options you customized to the new YAML when upgrading to a new binary version (you should use the latest YAML when upgrading to a new version).
Either way, here are some values in orderer.yaml you must review. You will notice that some of these fields are the same as those in core.yaml only with different names.

General.LocalMSPID: this is the name of the local MSP, generated by your CA, of your orderer organization.
General.LocalMSPDir: the place where the local MSP for the ordering node is located. Note that it is a best practice to mount this volume external to your container.
General.ListenAddress and General.ListenPort: represents the endpoint to other ordering nodes in the same organization.
FileLedger: although ordering nodes do not have a state database, they still all carry copies of the blockchain, as this allows them to verify permissions using the latest config block. Therefore the ledger fields should be customized with the correct file path.
Cluster: these values are important for ordering service nodes that communicate with other ordering nodes, such as in a Raft based ordering service.
General.BootstrapFile: this is the name of the configuration block used to bootstrap an ordering node. If this node is the first node generated in an ordering service, this file will have to be generated and is known as the âgenesis blockâ.
General.BootstrapMethod: the method by which the bootstrap block is given. For now, this can only be file, in which the file in the BootstrapFile is specified. Starting in 2.0, you can specify none to simply start the orderer without bootstrapping.
Consensus: determines the key/value pairs allowed by the consensus plugin (Raft ordering services are supported and recommended) for the Write Ahead Logs (WALDir) and Snapshots (SnapDir).

When youâre comfortable with how your ordering node has been configured, how your volumes are mounted, and your backend configuration, you can run the command to launch the ordering node (this command will depend on your backend configuration).



Next stepsÂ¶
Blockchain networks are all about connection, so once youâve deployed nodes, youâll obviously want to connect them to other nodes! If you have a peer organization and a peer, youâll want to join your organization to a consortium and join or Channels. If you have an ordering node, you will want to add peer organizations to your consortium. Youâll also want to learn how to develop chaincode, which you can learn about in the topics The scenario and Fabric chaincode lifecycle.
Part of the process of connecting nodes and creating channels will involve modifying policies to fit the use cases of business networks. For more information about policies, check out Policies.
One of the common tasks in a Fabric will be the editing of existing channels. For a tutorial about that process, check out Updating a channel configuration. One popular channel update is to add an org to an existing channel. For a tutorial about that specific process, check out Adding an Org to a Channel. For information about upgrading nodes after they have been deployed, check out Upgrading your components.








Next 
 Previous




        © Copyright Hyperledger 2020.
    
This work is licensed under a Creative Commons Attribution 4.0 International License



          Revision 77bafd68.
        


  Built with Sphinx using a theme provided by Read the Docs. 



https://hyperledger-fabric.readthedocs.io/en/release-2.0/ops_guide.html



Docs »
Operations Guides

 Edit on GitHub







Operations GuidesÂ¶


Setting up an ordering node
Membership Service Providers (MSP)
Using a Hardware Security Module (HSM)
Channel Configuration (configtx)
Endorsement policies
Pluggable transaction endorsement and validation
Access Control Lists (ACL)
MSP Implementation with Identity Mixer
Identity Mixer MSP configuration generator (idemixgen)
The Operations Service
Metrics Reference
External Builders and Launchers
Chaincode as an external service
Error handling
Logging Control
Securing Communication With Transport Layer Security (TLS)
Configuring and operating a Raft ordering service
Migrating from Kafka to Raft
Bringing up a Kafka-based Ordering Service









Next 
 Previous




        © Copyright Hyperledger 2020.
    
This work is licensed under a Creative Commons Attribution 4.0 International License



          Revision 77bafd68.
        


  Built with Sphinx using a theme provided by Read the Docs. 



https://hyperledger-fabric.readthedocs.io/en/release-2.0/upgrade.html



Docs »
Upgrading to the latest release

 Edit on GitHub







Upgrading to the latest releaseÂ¶
If youâre familiar with previous releases of Hyperledger Fabric, youâre aware
that upgrading the nodes and channels to the latest version of Fabric is, at a
high level, a four step process.

Backup the ledger and MSPs.
Upgrade the orderer binaries in a rolling fashion to the latest Fabric version.
Upgrade the peer binaries in a rolling fashion to the latest Fabric version.
Update the orderer system channel and any application channels to the latest
capability levels, where available. Note that some releases will have
capabilities in all groups while other releases may have few or even no new
capabilities at all.

For more information about capabilities, check out Channel capabilities.
For a look at how these upgrade processes are accomplished, please consult these
tutorials:

Upgrading your components. Components should be upgraded to the latest
version before updating any capabilities.
Updating the capability level of a channel. Completed after updating the versions of all nodes.
Enabling the new chaincode lifecycle. Necessary to add organization specific endorsement
policies central to the new chaincode lifecycle for Fabric v2.0.

As the upgrading of nodes and increasing the capability levels of channels is by
now considered a standard Fabric process, we will not show the specific commands
for upgrading to the newest release. Similarly, there is no script in the fabric-samples
repo that will upgrade a sample network from the previous release to this one,
as there has been for previous releases.

Note
It is a best practice to upgrade your SDK to the latest version as a
part of a general upgrade of your network. While the SDK will always
be compatible with equivalent releases of Fabric and lower, it might
be necessary to upgrade to the latest SDK to leverage the latest Fabric
features. Consult the documentation of the Fabric SDK you are using
for information about how to upgrade.


Upgrading to the latest release

Considerations for getting to v2.0
Upgrading your components
Updating the capability level of a channel
Enabling the new chaincode lifecycle









Next 
 Previous




        © Copyright Hyperledger 2020.
    
This work is licensed under a Creative Commons Attribution 4.0 International License



          Revision 77bafd68.
        


  Built with Sphinx using a theme provided by Read the Docs. 



https://hyperledger-fabric.readthedocs.io/en/release-2.0/command_ref.html



Docs »
Commands Reference

 Edit on GitHub







Commands ReferenceÂ¶


peer
peer chaincode
peer lifecycle chaincode
peer channel
peer version
peer node
configtxgen
configtxlator
cryptogen
Service Discovery CLI
Fabric-CA Commands









Next 
 Previous




        © Copyright Hyperledger 2020.
    
This work is licensed under a Creative Commons Attribution 4.0 International License



          Revision 77bafd68.
        


  Built with Sphinx using a theme provided by Read the Docs. 



https://hyperledger-fabric.readthedocs.io/en/release-2.0/architecture.html



Docs »
Architecture Reference

 Edit on GitHub







Architecture ReferenceÂ¶


Hyperledger Fabric CA's User Guide
Hyperledger Fabric SDKs
Transaction Flow
Service Discovery
Defining capability requirements
Channels
CouchDB as the State Database
Peer channel-based event services
Private Data
Read-Write set semantics
Gossip data dissemination protocol









Next 
 Previous




        © Copyright Hyperledger 2020.
    
This work is licensed under a Creative Commons Attribution 4.0 International License



          Revision 77bafd68.
        


  Built with Sphinx using a theme provided by Read the Docs. 



https://hyperledger-fabric.readthedocs.io/en/release-2.0/Fabric-FAQ.html



Docs »
Frequently Asked Questions

 Edit on GitHub







Frequently Asked QuestionsÂ¶

EndorsementÂ¶
Endorsement architecture:




Question:How many peers in the network need to endorse a transaction?

Answer:The number of peers required to endorse a transaction is driven by the
endorsement policy that is specified in the chaincode definition.

Question:Does an application client need to connect to all peers?

Answer:Clients only need to connect to as many peers as are required by the
endorsement policy for the chaincode.





Security & Access ControlÂ¶




Question:How do I ensure data privacy?


Answer:There are various aspects to data privacy. First, you can segregate your
network into channels, where each channel represents a subset of participants
that are authorized to see the data for the chaincodes that are deployed to
that channel.
Second, you can use private-data to keep ledger data private from
other organizations on the channel. A private data collection allows a
defined subset of organizations on a channel the ability to endorse, commit,
or query private data without having to create a separate channel.
Other participants on the channel receive only a hash of the data.
For more information refer to the Using Private Data in Fabric tutorial.
Note that the key concepts topic also explains when to use private data instead of a channel.
Third, as an alternative to Fabric hashing the data using private data,
the client application can hash or encrypt the data before calling
chaincode. If you hash the data then you will need to provide a means to
share the source data. If you encrypt the data then you will need to provide
a means to share the decryption keys.
Fourth, you can restrict data access to certain roles in your organization, by
building access control into the chaincode logic.
Fifth, ledger data at rest can be encrypted via file system encryption on the
peer, and data in-transit is encrypted via TLS.


Question:Do the orderers see the transaction data?


Answer:No, the orderers only order transactions, they do not open the transactions.
If you do not want the data to go through the orderers at all, then utilize
the private data feature of Fabric.  Alternatively, you can hash or encrypt
the data in the client application before calling chaincode. If you encrypt
the data then you will need to provide a means to share the decryption keys.






Application-side Programming ModelÂ¶




Question:How do application clients know the outcome of a transaction?


Answer:The transaction simulation results are returned to the client by the
endorser in the proposal response.  If there are multiple endorsers, the
client can check that the responses are all the same, and submit the results
and endorsements for ordering and commitment. Ultimately the committing peers
will validate or invalidate the transaction, and the client becomes
aware of the outcome via an event, that the SDK makes available to the
application client.


Question:How do I query the ledger data?


Answer:Within chaincode you can query based on keys. Keys can be queried by range,
and composite keys can be modeled to enable equivalence queries against
multiple parameters. For example a composite key of (owner,asset_id) can be
used to query all assets owned by a certain entity. These key-based queries
can be used for read-only queries against the ledger, as well as in
transactions that update the ledger.
If you model asset data as JSON in chaincode and use CouchDB as the state
database, you can also perform complex rich queries against the chaincode
data values, using the CouchDB JSON query language within chaincode. The
application client can perform read-only queries, but these responses are
not typically submitted as part of transactions to the ordering service.


Question:How do I query the historical data to understand data provenance?


Answer:The chaincode API GetHistoryForKey() will return history of
values for a key.


Question:How to guarantee the query result is correct, especially when the peer being
queried may be recovering and catching up on block processing?


Answer:The client can query multiple peers, compare their block heights, compare
their query results, and favor the peers at the higher block heights.






Chaincode (Smart Contracts and Digital Assets)Â¶




Question:Does Hyperledger Fabric support smart contract logic?


Answer:Yes. We call this feature Chaincode. It is our interpretation of the
smart contract method/algorithm, with additional features.
A chaincode is programmatic code deployed on the network, where it is
executed and validated by chain validators together during the consensus
process. Developers can use chaincodes to develop business contracts,
asset definitions, and collectively-managed decentralized applications.


Question:How do I create a business contract?


Answer:There are generally two ways to develop business contracts: the first way is
to code individual contracts into standalone instances of chaincode; the
second way, and probably the more efficient way, is to use chaincode to
create decentralized applications that manage the life cycle of one or
multiple types of business contracts, and let end users instantiate
instances of contracts within these applications.


Question:How do I create assets?


Answer:Users can use chaincode (for business rules) and membership service (for
digital tokens) to design assets, as well as the logic that manages them.
There are two popular approaches to defining assets in most blockchain
solutions: the stateless UTXO model, where account balances are encoded
into past transaction records; and the account model, where account
balances are kept in state storage space on the ledger.
Each approach carries its own benefits and drawbacks. This blockchain
technology does not advocate either one over the other. Instead, one of our
first requirements was to ensure that both approaches can be easily
implemented.


Question:Which languages are supported for writing chaincode?


Answer:Chaincode can be written in any programming language and executed in
containers. Currently, Golang, node.js and java chaincode are supported.


Question:Does the Hyperledger Fabric have native currency?


Answer:No. However, if you really need a native currency for your chain network,
you can develop your own native currency with chaincode. One common attribute
of native currency is that some amount will get transacted (the chaincode
defining that currency will get called) every time a transaction is processed
on its chain.






Differences in Most Recent ReleasesÂ¶




Question:Where can I find what  are the highlighted differences between releases?

Answer:The differences between any subsequent releases are provided together with
the Releases.

Question:Where to get help for the technical questions not answered above?

Answer:Please use StackOverflow.





Ordering ServiceÂ¶




Question:I have an ordering service up and running and want to switch consensus
algorithms. How do I do that?

Answer:This is explicitly not supported.







Question:What is the orderer system channel?

Answer:The orderer system channel (sometimes called ordering system channel) is the
channel the orderer is initially bootstrapped with. It is used to orchestrate
channel creation. The orderer system channel defines consortia and the initial
configuration for new channels. At channel creation time, the organization
definition in the consortium, the /Channel groupâs values and policies, as
well as the /Channel/Orderer groupâs values and policies, are all combined
to form the new initial channel definition.







Question:If I update my application channel, should I update my orderer system
channel?

Answer:Once an application channel is created, it is managed independently of any
other channel (including the orderer system channel). Depending on the
modification, the change may or may not be desirable to port to other
channels. In general, MSP changes should be synchronized across all channels,
while policy changes are more likely to be specific to a particular channel.







Question:Can I have an organization act both in an ordering and application role?

Answer:Although this is possible, it is a highly discouraged configuration. By
default the /Channel/Orderer/BlockValidation policy allows any valid
certificate of the ordering organizations to sign blocks. If an organization
is acting both in an ordering and application role, then this policy should be
updated to restrict block signers to the subset of certificates authorized for
ordering.







Question:I want to write a consensus implementation for Fabric. Where do I begin?

Answer:A consensus plugin needs to implement the Consenter and Chain
interfaces defined in the consensus package. There is a plugin built
against raft . You can study it to learn more for your own implementation. The ordering service code can be found under
the orderer package.







Question:I want to change my ordering service configurations, e.g. batch timeout,
after I start the network, what should I do?

Answer:This falls under reconfiguring the network. Please consult the topic on
configtxlator.




BFTÂ¶




Question:When is a BFT version of the ordering service going to be available?

Answer:No date has been set. We are working towards a release during the 1.x cycle,
i.e. it will come with a minor version upgrade in Fabric. Track FAB-33 for
updates.












Next 
 Previous




        © Copyright Hyperledger 2020.
    
This work is licensed under a Creative Commons Attribution 4.0 International License



          Revision 77bafd68.
        


  Built with Sphinx using a theme provided by Read the Docs. 



https://hyperledger-fabric.readthedocs.io/en/release-2.0/CONTRIBUTING.html



Docs »
Contributions Welcome!

 Edit on GitHub







Note
Users who are migrating from Gerrit to GitHub: You can follow simple
Git workflows to move your development from Gerrit to GitHub. After
forking the Fabric repo, simply push the branches you want to save from
your current Gerrit-based local repo to your remote forked repository.
Once youâve pushed the changes you want to save, simply delete your
local Gerrit-based repository and clone your fork.
For a basic Git workflow recommendation please see our doc at
GitHub Contributions.


Contributions Welcome!Â¶
We welcome contributions to Hyperledger in many forms, and
thereâs always plenty to do!
First things first, please review the Hyperledger Code of
Conduct
before participating. It is important that we keep things civil.

Ways to contributeÂ¶
There are many ways you can contribute to Hyperledger Fabric, both as a user and
as a developer.
As a user:

Making Feature/Enhancement Proposals
Reporting bugs
Help test an upcoming Epic on the
release roadmap.
Contact the Epic assignee via the Jira work item or on
RocketChat.

As a developer:

If you only have a little time, consider picking up a
âhelp-wantedâ task,
see Fixing issues and working stories.
If you can commit to full-time development, either propose a new feature
(see Making Feature/Enhancement Proposals) and
bring a team to implement it, or join one of the teams working on an existing Epic.
If you see an Epic that interests you on the
release roadmap,
contact the Epic assignee via the Jira work item or on RocketChat.



Getting a Linux Foundation accountÂ¶
In order to participate in the development of the Hyperledger Fabric
project, you will need a Linux Foundation
account. Once you have a LF ID you will be able to
access all the Hyperledger community tools, including
Jira issue management,
RocketChat, and the
Wiki (for editing, only).
Follow the steps below to create a Linux Foundation account if you donât
already have one.

Go to the Linux Foundation ID
website.
Select the option I need to create a Linux Foundation ID, and fill
out the form that appears.
Wait a few minutes, then look for an email message with the subject line:
âValidate your Linux Foundation ID emailâ.
Open the received URL to validate your email address.
Verify that your browser displays the message
You have successfully validated your e-mail address.
Access Jira issue management, or
RocketChat.



Project GovernanceÂ¶
Hyperledger Fabric is managed under an open governance model as described in
our charter. Projects and
sub-projects are lead by a set of maintainers. New sub-projects can
designate an initial set of maintainers that will be approved by the
top-level projectâs existing maintainers when the project is first
approved.

MaintainersÂ¶
The Fabric project is lead by the projectâs top level maintainers.
The maintainers are responsible for reviewing and merging all patches submitted
for review, and they guide the overall technical direction of the project within
the guidelines established by the Hyperledger Technical Steering Committee (TSC).


Becoming a maintainerÂ¶
The projectâs maintainers will, from time-to-time, consider
adding or removing a maintainer. An existing maintainer can submit a
change set to the maintainers file. A nominated
Contributor may become a Maintainer by a majority approval of the proposal
by the existing Maintainers. Once approved, the change set is then merged
and the individual is added to (or alternatively, removed from) the maintainers
group. Maintainers may be removed by explicit resignation, for prolonged
inactivity (3 or more months), or for some infraction of the code of conduct
or by consistently demonstrating poor judgement. A maintainer removed for
inactivity should be restored following a sustained resumption of contributions
and reviews (a month or more) demonstrating a renewed commitment to the project.


Release cadenceÂ¶
The Fabric maintainers have settled on a quarterly (approximately) release
cadence (see releases).
At any given time, there will be a stable LTS (long term support) release branch,
as well as the master branch for upcoming new features.
Follow the discussion on the #fabric-release channel in RocketChat.


Making Feature/Enhancement ProposalsÂ¶
First, take time to review
JIRA
to be sure that there isnât already an open (or recently closed) proposal for the
same function. If there isnât, to make a proposal we recommend that you open a
JIRA Epic or Story, whichever seems to best fit the circumstance and
link or inline a âone pagerâ of the proposal that states what the feature would
do and, if possible, how it might be implemented. It would help also to make a
case for why the feature should be added, such as identifying specific use
case(s) for which the feature is needed and a case for what the benefit would be
should the feature be implemented. Once the JIRA issue is created, and the
âone pagerâ either attached, inlined in the description field, or a link to a
publicly accessible document is added to the description, send an introductory
email to the fabric@lists.hyperledger.org mailing list linking the
JIRA issue, and soliciting feedback.
Discussion of the proposed feature should be conducted in the JIRA issue itself,
so that we have a consistent pattern within our community as to where to find
design discussion.
Getting the support of three or more of the Hyperledger Fabric maintainers for
the new feature will greatly enhance the probability that the featureâs related
PRs will be included in a subsequent release.


Maintainers meetingÂ¶
The maintainers hold regular maintainers meetings.
The purpose of the maintainers meeting is to plan for and review the progress of
releases, and to discuss the technical and operational direction of the project
and sub-projects.
Please see the
wiki
for maintainer meeting details.
New feature/enhancement proposals as described above should be presented to a
maintainers meeting for consideration, feedback and acceptance.


Release roadmapÂ¶
The Fabric release roadmap of epics is maintained in
JIRA.


CommunicationsÂ¶
We use RocketChat for communication
and Google Hangoutsâ¢ for screen sharing between developers. Our
development planning and prioritization is done in
JIRA, and we take longer running
discussions/decisions to the mailing
list.



Contribution guideÂ¶

Install prerequisitesÂ¶
Before we begin, if you havenât already done so, you may wish to check that
you have all the prerequisites installed on the platform(s)
on which youâll be developing blockchain applications and/or operating
Hyperledger Fabric.


Getting helpÂ¶
If you are looking for something to work on, or need some expert
assistance in debugging a problem or working out a fix to an issue, our
community is always eager to
help. We hang out on
Chat, IRC
(#hyperledger on freenode.net) and the mailing
lists. Most of us donât bite :grin:
and will be glad to help. The only silly question is the one you donât
ask. Questions are in fact a great way to help improve the project as
they highlight where our documentation could be clearer.


Reporting bugsÂ¶
If you are a user and you have found a bug, please submit an issue using
JIRA.
Before you create a new JIRA issue, please try to search the existing items to
be sure no one else has previously reported it. If it has been previously
reported, then you might add a comment that you also are interested in seeing
the defect fixed.

Note
If the defect is security-related, please follow the Hyperledger
security bug reporting process.

If it has not been previously reported, you may either submit a PR with a
well documented commit message describing the defect and the fix, or you
may create a new JIRA. Please try to provide
sufficient information for someone else to reproduce the
issue. One of the projectâs maintainers should respond to your issue within 24
hours. If not, please bump the issue with a comment and request that it be
reviewed. You can also post to the relevant Hyperledger Fabric channel in
Hyperledger Chat.  For example, a doc bug should
be broadcast to #fabric-documentation, a database bug to #fabric-ledger,
and so onâ¦


Submitting your fixÂ¶
If you just submitted a JIRA for a bug youâve discovered, and would like to
provide a fix, we would welcome that gladly! Please assign the JIRA issue to
yourself, then submit a pull request (PR). Please refer to GitHub Contributions
for a detailed workflow.


Fixing issues and working storiesÂ¶
Review the issues
list and find
something that interests you. You could also check the
âhelp-wantedâ
list. It is wise to start with something relatively straight forward and
achievable, and that no one is already assigned. If no one is assigned,
then assign the issue to yourself. Please be considerate and rescind the
assignment if you cannot finish in a reasonable time, or add a comment
saying that you are still actively working the issue if you need a
little more time.


Reviewing submitted Pull Requests (PRs)Â¶
Another way to contribute and learn about Hyperledger Fabric is to help the
maintainers with the review of the PRs that are open. Indeed
maintainers have the difficult role of having to review all the PRs
that are being submitted and evaluate whether they should be merged or
not. You can review the code and/or documentation changes, test the
changes, and tell the submitters and maintainers what you think. Once
your review and/or test is complete just reply to the PR with your
findings, by adding comments and/or voting. A comment saying something
like âI tried it on system X and it worksâ or possibly âI got an error
on system X: xxx â will help the maintainers in their evaluation. As a
result, maintainers will be able to process PRs faster and everybody
will gain from it.
Just browse through the open PRs on GitHub to get started.


PR AgingÂ¶
As the Fabric project has grown, so too has the backlog of open PRs. One
problem that nearly all projects face is effectively managing that backlog
and Fabric is no exception. In an effort to keep the backlog of Fabric and
related project PRs manageable, we are introducing an aging policy which
will be enforced by bots.  This is consistent with how other large projects
manage their PR backlog.


PR Aging PolicyÂ¶
The Fabric project maintainers will automatically monitor all PR activity for
delinquency. If a PR has not been updated in 2 weeks, a reminder comment will be
added requesting that the PR either be updated to address any outstanding
comments or abandoned if it is to be withdrawn. If a delinquent PR goes another
2 weeks without an update, it will be automatically abandoned. If a PR has aged
more than 2 months since it was originally submitted, even if it has activity,
it will be flagged for maintainer review.
If a submitted PR has passed all validation but has not been reviewed in 72
hours (3 days), it will be flagged to the #fabric-pr-review channel daily until
it receives a review comment(s).
This policy applies to all official Fabric projects (fabric, fabric-ca,
fabric-samples, fabric-test, fabric-sdk-node, fabric-sdk-java, fabric-gateway-java,
fabric-chaincode-node, fabric-chaincode-java, fabric-chaincode-evm,
fabric-baseimage, and fabric-amcl).


Setting up development environmentÂ¶
Next, try building the project in your local
development environment to ensure that everything is set up correctly.


What makes a good pull request?Â¶

One change at a time. Not five, not three, not ten. One and only one.
Why? Because it limits the blast area of the change. If we have a
regression, it is much easier to identify the culprit commit than if
we have some composite change that impacts more of the code.
Include a link to the JIRA story for the change. Why? Because a) we
want to track our velocity to better judge what we think we can
deliver and when and b) because we can justify the change more
effectively. In many cases, there should be some discussion around a
proposed change and we want to link back to that from the change
itself.
Include unit and integration tests (or changes to existing tests)
with every change. This does not mean just happy path testing,
either. It also means negative testing of any defensive code that it
correctly catches input errors. When you write code, you are
responsible to test it and provide the tests that demonstrate that
your change does what it claims. Why? Because without this we have no
clue whether our current code base actually works.
Unit tests should have NO external dependencies. You should be able
to run unit tests in place with go test or equivalent for the
language. Any test that requires some external dependency (e.g. needs
to be scripted to run another component) needs appropriate mocking.
Anything else is not unit testing, it is integration testing by
definition. Why? Because many open source developers do Test Driven
Development. They place a watch on the directory that invokes the
tests automagically as the code is changed. This is far more
efficient than having to run a whole build between code changes. See
this definition
of unit testing for a good set of criteria to keep in mind for writing
effective unit tests.
Minimize the lines of code per PR. Why? Maintainers have day jobs,
too. If you send a 1,000 or 2,000 LOC change, how long do you think
it takes to review all of that code? Keep your changes to < 200-300
LOC, if possible. If you have a larger change, decompose it into
multiple independent changes. If you are adding a bunch of new
functions to fulfill the requirements of a new capability, add them
separately with their tests, and then write the code that uses them
to deliver the capability. Of course, there are always exceptions. If
you add a small change and then add 300 LOC of tests, you will be
forgiven;-) If you need to make a change that has broad impact or a
bunch of generated code (protobufs, etc.). Again, there can be
exceptions.


Note
Large pull requests, e.g. those with more than 300 LOC are more than likely
not going to receive an approval, and youâll be asked to refactor
the change to conform with this guidance.


Write a meaningful commit message. Include a meaningful 55 (or less)
character title, followed by a blank line, followed by a more
comprehensive description of the change. Each change MUST include the JIRA
identifier corresponding to the change (e.g. [FAB-1234]). This can be
in the title but should also be in the body of the commit message.


Note
Example commit message:
[FAB-1234] fix foobar() panic

Fix [FAB-1234] added a check to ensure that when foobar(foo string)
is called, that there is a non-empty string argument.



Finally, be responsive. Donât let a pull request fester with review
comments such that it gets to a point that it requires a rebase. It only
further delays getting it merged and adds more work for you - to
remediate the merge conflicts.



Legal stuffÂ¶
Note: Each source file must include a license header for the Apache
Software License 2.0. See the template of the license header.
We have tried to make it as easy as possible to make contributions. This
applies to how we handle the legal aspects of contribution. We use the
same approachâthe Developerâs Certificate of Origin 1.1
(DCO)âthat the LinuxÂ® Kernel
community uses
to manage code contributions.
We simply ask that when submitting a patch for review, the developer
must include a sign-off statement in the commit message.
Here is an example Signed-off-by line, which indicates that the
submitter accepts the DCO:
Signed-off-by: John Doe <john.doe@example.com>


You can include this automatically when you commit a change to your
local git repository using git commit -s.


Related TopicsÂ¶


Using Jira to understand current work items
Setting up the development environment
Building Hyperledger Fabric
Configuration
Coding guidelines
Generating gRPC code
Adding or updating Go packages










Next 
 Previous




        © Copyright Hyperledger 2020.
    
This work is licensed under a Creative Commons Attribution 4.0 International License



          Revision 77bafd68.
        


  Built with Sphinx using a theme provided by Read the Docs. 



https://hyperledger-fabric.readthedocs.io/en/release-2.0/glossary.html



Docs »
Glossary

 Edit on GitHub







GlossaryÂ¶
Terminology is important, so that all Hyperledger Fabric users and developers
agree on what we mean by each specific term. What is a smart contract for
example. The documentation will reference the glossary as needed, but feel free
to read the entire thing in one sitting if you like; itâs pretty enlightening!

Anchor PeerÂ¶
Used by gossip to make sure peers in different organizations know about each other.
When a configuration block that contains an update to the anchor peers is committed,
peers reach out to the anchor peers and learn from them about all of the peers known
to the anchor peer(s). Once at least one peer from each organization has contacted an
anchor peer, the anchor peer learns about every peer in the channel. Since gossip
communication is constant, and because peers always ask to be told about the existence
of any peer they donât know about, a common view of membership can be established for
a channel.
For example, letâs assume we have three organizations â A, B, C â in the channel
and a single anchor peer â peer0.orgC â defined for organization C.
When peer1.orgA (from organization A) contacts peer0.orgC, it will
tell peer0.orgC about peer0.orgA. And when at a later time peer1.orgB
contacts peer0.orgC, the latter would tell the former about peer0.orgA.
From that point forward, organizations A and B would start exchanging
membership information directly without any assistance from peer0.orgC.
As communication across organizations depends on gossip in order to work, there must
be at least one anchor peer defined in the channel configuration. It is strongly
recommended that every organization provides its own set of anchor peers for high
availability and redundancy.


ACLÂ¶
An ACL, or Access Control List, associates access to specific peer
resources (such as system chaincode APIs or event services) to a Policy
(which specifies how many and what types of organizations or roles are
required). The ACL is part of a channelâs configuration. It is therefore
persisted in the channelâs configuration blocks, and can be updated using the
standard configuration update mechanism.
An ACL is formatted as a list of key-value pairs, where the key identifies
the resource whose access we wish to control, and the value identifies the
channel policy (group) that is allowed to access it. For example
lscc/GetDeploymentSpec: /Channel/Application/Readers
defines that the access to the life cycle chaincode GetDeploymentSpec API
(the resource) is accessible by identities which satisfy the
/Channel/Application/Readers policy.
A set of default ACLs is provided in the configtx.yaml file which is
used by configtxgen to build channel configurations. The defaults can be set
in the top level âApplicationâ section of configtx.yaml or overridden
on a per profile basis in the âProfilesâ section.


BlockÂ¶


Block B1 is linked to block B0. Block B2 is linked to block B1.


A block contains an ordered set of transactions. It is cryptographically linked
to the preceding block, and in turn it is linked to be subsequent blocks. The
first block in such a chain of blocks is called the genesis block. Blocks
are created by the ordering service, and then validated and committed by peers.


ChainÂ¶


Blockchain B contains blocks 0, 1, 2.


The ledgerâs chain is a transaction log structured as hash-linked blocks of
transactions. Peers receive blocks of transactions from the ordering service, mark
the blockâs transactions as valid or invalid based on endorsement policies and
concurrency violations, and append the block to the hash chain on the peerâs
file system.


ChaincodeÂ¶
See Smart-Contract.


ChannelÂ¶


Channel C connects application A1, peer P2 and ordering service O1.


A channel is a private blockchain overlay which allows for data
isolation and confidentiality. A channel-specific ledger is shared across the
peers in the channel, and transacting parties must be authenticated to
a channel in order to interact with it.  Channels are defined by a
Configuration-Block.


CommitÂ¶
Each Peer on a channel validates ordered blocks of
transactions and then commits (writes/appends) the blocks to its replica of the
channel Ledger. Peers also mark each transaction in each block
as valid or invalid.


Concurrency Control Version CheckÂ¶
Concurrency Control Version Check is a method of keeping ledger state in sync across
peers on a channel. Peers execute transactions in parallel, and before committing
to the ledger, peers check whether the state read at the time the transaction was executed
has been modified. If the data read for the transaction has changed between execution time and
commit time, then a Concurrency Control Version Check violation has
occurred, and the transaction is marked as invalid on the ledger and values
are not updated in the state database.


Configuration BlockÂ¶
Contains the configuration data defining members and policies for a system
chain (ordering service) or channel. Any configuration modifications to a
channel or overall network (e.g. a member leaving or joining) will result
in a new configuration block being appended to the appropriate chain. This
block will contain the contents of the genesis block, plus the delta.


ConsensusÂ¶
A broader term overarching the entire transactional flow, which serves to generate
an agreement on the order and to confirm the correctness of the set of transactions
constituting a block.


Consenter setÂ¶
In a Raft ordering service, these are the ordering nodes actively participating
in the consensus mechanism on a channel. If other ordering nodes exist on the
system channel, but are not a part of a channel, they are not part of that
channelâs consenter set.


ConsortiumÂ¶
A consortium is a collection of non-orderer organizations on the blockchain
network. These are the organizations that form and join channels and that own
peers. While a blockchain network can have multiple consortia, most blockchain
networks have a single consortium. At channel creation time, all organizations
added to the channel must be part of a consortium. However, an organization
that is not defined in a consortium may be added to an existing channel.


Chaincode definitionÂ¶
A chaincode definition is used by organizations to agree on the parameters of a
chaincode before it can be used on a channel. Each channel member that wants to
use the chaincode to endorse transactions or query the ledger needs to approve
a chaincode definition for their organization. Once enough channel members have
approved a chaincode definition to meet the Lifecycle Endorsement policy (which
is set to a majority of organizations in the channel by default), the chaincode
definition can be committed to the channel. After the definition is committed,
the first invoke of the chaincode (or, if requested, the execution of the Init
function) will start the chaincode on the channel.


Dynamic MembershipÂ¶
Hyperledger Fabric supports the addition/removal of members, peers, and ordering service
nodes, without compromising the operationality of the overall network. Dynamic
membership is critical when business relationships adjust and entities need to
be added/removed for various reasons.


EndorsementÂ¶
Refers to the process where specific peer nodes execute a chaincode transaction and return
a proposal response to the client application. The proposal response includes the
chaincode execution response message, results (read set and write set), and events,
as well as a signature to serve as proof of the peerâs chaincode execution.
Chaincode applications have corresponding endorsement policies, in which the endorsing
peers are specified.


Endorsement policyÂ¶
Defines the peer nodes on a channel that must execute transactions attached to a
specific chaincode application, and the required combination of responses (endorsements).
A policy could require that a transaction be endorsed by a minimum number of
endorsing peers, a minimum percentage of endorsing peers, or by all endorsing
peers that are assigned to a specific chaincode application. Policies can be
curated based on the application and the desired level of resilience against
misbehavior (deliberate or not) by the endorsing peers. A transaction that is submitted
must satisfy the endorsement policy before being marked as valid by committing peers.


FollowerÂ¶
In a leader based consensus protocol, such as Raft, these are the nodes which
replicate log entries produced by the leader. In Raft, the followers also receive
âheartbeatâ messages from the leader. In the event that the leader stops sending
those message for a configurable amount of time, the followers will initiate a
leader election and one of them will be elected leader.


Genesis BlockÂ¶
The configuration block that initializes the ordering service, or serves as the
first block on a chain.


Gossip ProtocolÂ¶
The gossip data dissemination protocol performs three functions:
1) manages peer discovery and channel membership;
2) disseminates ledger data across all peers on the channel;
3) syncs ledger state across all peers on the channel.
Refer to the Gossip topic for more details.


Hyperledger Fabric CAÂ¶
Hyperledger Fabric CA is the default Certificate Authority component, which
issues PKI-based certificates to network member organizations and their users.
The CA issues one root certificate (rootCert) to each member and one enrollment
certificate (ECert) to each authorized user.


InitÂ¶
A method to initialize a chaincode application. All chaincodes need to have an
an Init function. By default, this function is never executed. However you can
use the chaincode definition to request the execution of the Init function in
order to initialize the chaincode.


InstallÂ¶
The process of placing a chaincode on a peerâs file system.


InstantiateÂ¶
The process of starting and initializing a chaincode application on a specific
channel. After instantiation, peers that have the chaincode installed can accept
chaincode invocations.
NOTE: This method i.e. Instantiate was used in the 1.4.x and older versions of the chaincode
lifecycle. For the current procedure used to start a chaincode on a channel with
the new Fabric chaincode lifecycle introduced as part of Fabric v2.0,
see Chaincode-definition_.


InvokeÂ¶
Used to call chaincode functions. A client application invokes chaincode by
sending a transaction proposal to a peer. The peer will execute the chaincode
and return an endorsed proposal response to the client application. The client
application will gather enough proposal responses to satisfy an endorsement policy,
and will then submit the transaction results for ordering, validation, and commit.
The client application may choose not to submit the transaction results. For example
if the invoke only queried the ledger, the client application typically would not
submit the read-only transaction, unless there is desire to log the read on the ledger
for audit purpose. The invoke includes a channel identifier, the chaincode function to
invoke, and an array of arguments.


LeaderÂ¶
In a leader based consensus protocol, like Raft, the leader is responsible for
ingesting new log entries, replicating them to follower ordering nodes, and
managing when an entry is considered committed. This is not a special type
of orderer. It is only a role that an orderer may have at certain times, and
then not others, as circumstances determine.


Leading PeerÂ¶
Each Organization can own multiple peers on each channel that
they subscribe to. One or more of these peers should serve as the leading peer
for the channel, in order to communicate with the network ordering service on
behalf of the organization. The ordering service delivers blocks to the
leading peer(s) on a channel, who then distribute them to other peers within
the same organization.


LedgerÂ¶


A Ledger, âLâ

A ledger consists of two distinct, though related, parts â a âblockchainâ and
the âstate databaseâ, also known as âworld stateâ. Unlike other ledgers,
blockchains are immutable â that is, once a block has been added to the
chain, it cannot be changed. In contrast, the âworld stateâ is a database
containing the current value of the set of key-value pairs that have been added,
modified or deleted by the set of validated and committed transactions in the
blockchain.
Itâs helpful to think of there being one logical ledger for each channel in
the network. In reality, each peer in a channel maintains its own copy of the
ledger â which is kept consistent with every other peerâs copy through a
process called consensus. The term Distributed Ledger Technology
(DLT) is often associated with this kind of ledger â one that is logically
singular, but has many identical copies distributed across a set of network
nodes (peers and the ordering service).


Log entryÂ¶
The primary unit of work in a Raft ordering service, log entries are distributed
from the leader orderer to the followers. The full sequence of such entries known
as the âlogâ. The log is considered to be consistent if all members agree on the
entries and their order.


MemberÂ¶
See Organization.


Membership Service ProviderÂ¶


An MSP, âORG.MSPâ

The Membership Service Provider (MSP) refers to an abstract component of the
system that provides credentials to clients, and peers for them to participate
in a Hyperledger Fabric network. Clients use these credentials to authenticate
their transactions, and peers use these credentials to authenticate transaction
processing results (endorsements). While strongly connected to the transaction
processing components of the systems, this interface aims to have membership
services components defined, in such a way that alternate implementations of
this can be smoothly plugged in without modifying the core of transaction
processing components of the system.


Membership ServicesÂ¶
Membership Services authenticates, authorizes, and manages identities on a
permissioned blockchain network. The membership services code that runs in peers
and orderers both authenticates and authorizes blockchain operations.  It is a
PKI-based implementation of the Membership Services Provider (MSP) abstraction.


Ordering ServiceÂ¶
Also known as orderer. A defined collective of nodes that orders transactions into a block
and then distributes blocks to connected peers for validation and commit. The ordering service
exists independent of the peer processes and orders transactions on a first-come-first-serve basis
for all channels on the network.  It is designed to support pluggable implementations beyond the
out-of-the-box Kafka and Raft varieties. It is a common binding for the overall network; it
contains the cryptographic identity material tied to each Member.


OrganizationÂ¶



An organization, âORGâ

Also known as âmembersâ, organizations are invited to join the blockchain network
by a blockchain network provider. An organization is joined to a network by adding its
Membership Service Provider (MSP) to the network. The MSP defines how other members of the
network may verify that signatures (such as those over transactions) were generated by a valid
identity, issued by that organization. The particular access rights of identities within an MSP
are governed by policies which are also agreed upon when the organization is joined to the
network. An organization can be as large as a multi-national corporation or as small as an
individual. The transaction endpoint of an organization is a Peer. A collection of organizations
form a Consortium. While all of the organizations on a network are members, not every organization
will be part of a consortium.


PeerÂ¶


A peer, âPâ

A network entity that maintains a ledger and runs chaincode containers in order to perform
read/write operations to the ledger.  Peers are owned and maintained by members.


PolicyÂ¶
Policies are expressions composed of properties of digital identities, for
example: Org1.Peer OR Org2.Peer. They are used to restrict access to
resources on a blockchain network. For instance, they dictate who can read from
or write to a channel, or who can use a specific chaincode API via an ACL.
Policies may be defined in configtx.yaml prior to bootstrapping an ordering
service or creating a channel, or they can be specified when instantiating
chaincode on a channel. A default set of policies ship in the sample
configtx.yaml which will be appropriate for most networks.


Private DataÂ¶
Confidential data that is stored in a private database on each authorized peer,
logically separate from the channel ledger data. Access to this data is
restricted to one or more organizations on a channel via a private data
collection definition. Unauthorized organizations will have a hash of the
private data on the channel ledger as evidence of the transaction data. Also,
for further privacy, hashes of the private data go through the
Ordering-Service, not the private data itself, so this keeps private data
confidential from Orderer.


Private Data Collection (Collection)Â¶
Used to manage confidential data that two or more organizations on a channel
want to keep private from other organizations on that channel. The collection
definition describes a subset of organizations on a channel entitled to store
a set of private data, which by extension implies that only these organizations
can transact with the private data.


ProposalÂ¶
A request for endorsement that is aimed at specific peers on a channel. Each
proposal is either an Init or an Invoke (read/write) request.


QueryÂ¶
A query is a chaincode invocation which reads the ledger current state but does
not write to the ledger. The chaincode function may query certain keys on the ledger,
or may query for a set of keys on the ledger. Since queries do not change ledger state,
the client application will typically not submit these read-only transactions for ordering,
validation, and commit. Although not typical, the client application can choose to
submit the read-only transaction for ordering, validation, and commit, for example if the
client wants auditable proof on the ledger chain that it had knowledge of specific ledger
state at a certain point in time.


QuorumÂ¶
This describes the minimum number of members of the cluster that need to
affirm a proposal so that transactions can be ordered. For every consenter set,
this is a majority of nodes. In a cluster with five nodes, three must be
available for there to be a quorum. If a quorum of nodes is unavailable for any
reason, the cluster becomes unavailable for both read and write operations and
no new logs can be committed.


RaftÂ¶
New for v1.4.1, Raft is a crash fault tolerant (CFT) ordering service
implementation based on the etcd library
of the Raft protocol <https://raft.github.io/raft.pdf>`_. Raft follows a
âleader and followerâ model, where a leader node is elected (per channel) and
its decisions are replicated by the followers. Raft ordering services should
be easier to set up and manage than Kafka-based ordering services, and their
design allows organizations to contribute nodes to a distributed ordering
service.


Software Development Kit (SDK)Â¶
The Hyperledger Fabric client SDK provides a structured environment of libraries
for developers to write and test chaincode applications. The SDK is fully
configurable and extensible through a standard interface. Components, including
cryptographic algorithms for signatures, logging frameworks and state stores,
are easily swapped in and out of the SDK. The SDK provides APIs for transaction
processing, membership services, node traversal and event handling.
Currently, the two officially supported SDKs are for Node.js and Java, while two
more â Python and Go â are not yet official but can still be downloaded
and tested.


Smart ContractÂ¶
A smart contract is code â invoked by a client application external to the
blockchain network â that manages access and modifications to a set of
key-value pairs in the World State via Transaction. In Hyperledger Fabric,
smart contracts are packaged as chaincode. Chaincode is installed on peers
and then defined and used on one or more channels.


State DatabaseÂ¶
World state data is stored in a state database for efficient reads and queries
from chaincode. Supported databases include levelDB and couchDB.


System ChainÂ¶
Contains a configuration block defining the network at a system level. The
system chain lives within the ordering service, and similar to a channel, has
an initial configuration containing information such as: MSP information, policies,
and configuration details.  Any change to the overall network (e.g. a new org
joining or a new ordering node being added) will result in a new configuration block
being added to the system chain.
The system chain can be thought of as the common binding for a channel or group
of channels.  For instance, a collection of financial institutions may form a
consortium (represented through the system chain), and then proceed to create
channels relative to their aligned and varying business agendas.


TransactionÂ¶


A transaction, âTâ

Transactions are created when a chaincode is invoked from a client application
to read or write data from the ledger. Fabric application clients submit transaction proposals to
endorsing peers for execution and endorsement, gather the signed (endorsed) responses from those
endorsing peers, and then package the results and endorsements into a transaction that is
submitted to the ordering service. The ordering service orders and places transactions
in a block that is broadcast to the peers which validate and commit the transactions to the ledger
and update world state.


World StateÂ¶


The World State, âWâ

Also known as the âcurrent stateâ, the world state is a component of the
HyperLedger Fabric Ledger. The world state represents the latest values
for all keys included in the chain transaction log. Chaincode executes
transaction proposals against world state data because the world state provides
direct access to the latest value of these keys rather than having to calculate
them by traversing the entire transaction log. The world state will change
every time the value of a key changes (for example, when the ownership of a
car â the âkeyâ â is transferred from one owner to another â the
âvalueâ) or when a new key is added (a car is created). As a result, the world
state is critical to a transaction flow, since the current state of a key-value
pair must be known before it can be changed. Peers commit the latest values to
the ledger world state for each valid transaction included in a processed block.








Next 
 Previous




        © Copyright Hyperledger 2020.
    
This work is licensed under a Creative Commons Attribution 4.0 International License



          Revision 77bafd68.
        


  Built with Sphinx using a theme provided by Read the Docs. 



https://hyperledger-fabric.readthedocs.io/en/release-2.0/releases.html



Docs »
Releases

 Edit on GitHub







ReleasesÂ¶
Hyperledger Fabric releases are documented on the Fabric github page.







Next 
 Previous




        © Copyright Hyperledger 2020.
    
This work is licensed under a Creative Commons Attribution 4.0 International License



          Revision 77bafd68.
        


  Built with Sphinx using a theme provided by Read the Docs. 



https://hyperledger-fabric.readthedocs.io/en/release-2.0/questions.html



Docs »
Still Have Questions?

 Edit on GitHub







Still Have Questions?Â¶
We try to maintain a comprehensive set of documentation for various
audiences. However, we realize that often there are questions that
remain unanswered. For any technical questions relating to Hyperledger
Fabric not answered here, please use
StackOverflow.
Another approach to getting your questions answered to send an email to
the mailing
list
(fabric@lists.hyperledger.org), or ask your questions on
RocketChat (an alternative to Slack)
on the #fabric or #fabric-questions channel.

Note
Please, when asking about problems you are facing tell us
about the environment in which you are experiencing those
problems including the OS, which version of Docker you are
using, etc.








Next 
 Previous




        © Copyright Hyperledger 2020.
    
This work is licensed under a Creative Commons Attribution 4.0 International License



          Revision 77bafd68.
        


  Built with Sphinx using a theme provided by Read the Docs. 



https://hyperledger-fabric.readthedocs.io/en/release-2.0/status.html



Docs »
Status

 Edit on GitHub







StatusÂ¶
Hyperledger Fabric is in the Active state. For more information on the history of this project see our wiki page. Information on what Active entails can be found in
the Hyperledger Project Lifecycle document.







 Previous




        © Copyright Hyperledger 2020.
    
This work is licensed under a Creative Commons Attribution 4.0 International License



          Revision 77bafd68.
        


  Built with Sphinx using a theme provided by Read the Docs. 



https://hyperledger-fabric.readthedocs.io/en/release-2.0/questions.html



Docs »
Still Have Questions?

 Edit on GitHub







Still Have Questions?Â¶
We try to maintain a comprehensive set of documentation for various
audiences. However, we realize that often there are questions that
remain unanswered. For any technical questions relating to Hyperledger
Fabric not answered here, please use
StackOverflow.
Another approach to getting your questions answered to send an email to
the mailing
list
(fabric@lists.hyperledger.org), or ask your questions on
RocketChat (an alternative to Slack)
on the #fabric or #fabric-questions channel.

Note
Please, when asking about problems you are facing tell us
about the environment in which you are experiencing those
problems including the OS, which version of Docker you are
using, etc.








Next 
 Previous




        © Copyright Hyperledger 2020.
    
This work is licensed under a Creative Commons Attribution 4.0 International License



          Revision 77bafd68.
        


  Built with Sphinx using a theme provided by Read the Docs. 



